<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `src/solver_utils.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>solver_utils.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../haybale/index.html'><div class='logo-container'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">//! Simple utilities for interacting with the solver</span>

<span class="kw">use</span> <span class="ident">boolector</span>::{<span class="ident">Btor</span>, <span class="ident">BVSolution</span>, <span class="ident">SolverResult</span>};
<span class="kw">use</span> <span class="ident">boolector</span>::<span class="ident">option</span>::{<span class="ident">BtorOption</span>, <span class="ident">ModelGen</span>};
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">backend</span>::<span class="ident">BV</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">error</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">log</span>::<span class="ident">warn</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashSet</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">hash</span>::<span class="ident">Hash</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ops</span>::<span class="ident">Deref</span>;

<span class="doccomment">/// Returns `true` if current constraints are satisfiable, `false` if not.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Returns `Error::SolverError` if the query failed (e.g., was interrupted or timed out).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">sat</span>(<span class="ident">btor</span>: <span class="kw-2">&amp;</span><span class="ident">Btor</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">btor</span>.<span class="ident">sat</span>() {
        <span class="ident">SolverResult</span>::<span class="ident">Sat</span> <span class="op">=&gt;</span> <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>),
        <span class="ident">SolverResult</span>::<span class="ident">Unsat</span> <span class="op">=&gt;</span> <span class="prelude-val">Ok</span>(<span class="bool-val">false</span>),
        <span class="ident">SolverResult</span>::<span class="ident">Unknown</span> <span class="op">=&gt;</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">SolverError</span>(<span class="string">&quot;The query was interrupted, timed out, or otherwise failed&quot;</span>.<span class="ident">to_owned</span>())),
    }
}

<span class="doccomment">/// Returns `true` if the current constraints plus the additional constraints `conds`</span>
<span class="doccomment">/// are together satisfiable, or `false` if not.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Returns `Error::SolverError` if the query failed (e.g., was interrupted or timed out).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Does not permanently add the constraints in `conds` to the solver.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">sat_with_extra_constraints</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">B</span><span class="op">&gt;</span>(<span class="ident">btor</span>: <span class="kw-2">&amp;</span><span class="ident">Btor</span>, <span class="ident">constraints</span>: <span class="kw">impl</span> <span class="ident">IntoIterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">I</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>
    <span class="kw">where</span> <span class="ident">I</span>: <span class="ident">Deref</span><span class="op">&lt;</span><span class="ident">Target</span> <span class="op">=</span> <span class="ident">B</span><span class="op">&gt;</span>, <span class="ident">B</span>: <span class="ident">BV</span>
{
    <span class="ident">btor</span>.<span class="ident">push</span>(<span class="number">1</span>);
    <span class="kw">for</span> <span class="ident">constraint</span> <span class="kw">in</span> <span class="ident">constraints</span> {
        <span class="ident">constraint</span>.<span class="ident">assert</span>()<span class="question-mark">?</span>;
    }
    <span class="kw">let</span> <span class="ident">retval</span> <span class="op">=</span> <span class="ident">sat</span>(<span class="ident">btor</span>);
    <span class="ident">btor</span>.<span class="ident">pop</span>(<span class="number">1</span>);
    <span class="ident">retval</span>
}

<span class="doccomment">/// Returns `true` if under the current constraints, `a` and `b` must have the</span>
<span class="doccomment">/// same value. Returns `false` if `a` and `b` may have different values. (If the</span>
<span class="doccomment">/// current constraints are themselves unsatisfiable, that will result in</span>
<span class="doccomment">/// `true`.)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A common use case for this function is to test whether some `BV` must be</span>
<span class="doccomment">/// equal to a given concrete value. You can do this with something like</span>
<span class="doccomment">/// `bvs_must_be_equal(btor, bv, BV::from_u64(...))`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function and `bvs_can_be_equal()` are both more efficient than</span>
<span class="doccomment">/// `get_a_solution()` or `get_possible_solutions()`-type functions, as they do</span>
<span class="doccomment">/// not require full model generation. You should prefer this function or</span>
<span class="doccomment">/// `bvs_can_be_equal()` if they are sufficient for your needs.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bvs_must_be_equal</span><span class="op">&lt;</span><span class="ident">V</span>: <span class="ident">BV</span><span class="op">&gt;</span>(<span class="ident">btor</span>: <span class="kw-2">&amp;</span><span class="ident">Btor</span>, <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="ident">V</span>, <span class="ident">b</span>: <span class="kw-2">&amp;</span><span class="ident">V</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">sat_with_extra_constraints</span>(<span class="ident">btor</span>, <span class="kw-2">&amp;</span>[<span class="ident">a</span>.<span class="ident">_ne</span>(<span class="kw-2">&amp;</span><span class="ident">b</span>)])<span class="question-mark">?</span> {
        <span class="prelude-val">Ok</span>(<span class="bool-val">false</span>)
    } <span class="kw">else</span> {
        <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>)
    }
}

<span class="doccomment">/// Returns `true` if under the current constraints, `a` and `b` can have the</span>
<span class="doccomment">/// same value. Returns `false` if `a` and `b` cannot have the same value. (If</span>
<span class="doccomment">/// the current constraints are themselves unsatisfiable, that will also result</span>
<span class="doccomment">/// in `false`.)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A common use case for this function is to test whether some `BV` can be</span>
<span class="doccomment">/// equal to a given concrete value. You can do this with something like</span>
<span class="doccomment">/// `bvs_can_be_equal(btor, bv, BV::from_u64(...))`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function and `bvs_must_be_equal()` are both more efficient than</span>
<span class="doccomment">/// `get_a_solution()` or `get_possible_solutions()`-type functions, as they do</span>
<span class="doccomment">/// not require full model generation. You should prefer this function or</span>
<span class="doccomment">/// `bvs_must_be_equal()` if they are sufficient for your needs.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bvs_can_be_equal</span><span class="op">&lt;</span><span class="ident">V</span>: <span class="ident">BV</span><span class="op">&gt;</span>(<span class="ident">btor</span>: <span class="kw-2">&amp;</span><span class="ident">Btor</span>, <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="ident">V</span>, <span class="ident">b</span>: <span class="kw-2">&amp;</span><span class="ident">V</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">sat_with_extra_constraints</span>(<span class="ident">btor</span>, <span class="kw-2">&amp;</span>[<span class="ident">a</span>.<span class="ident">_eq</span>(<span class="kw-2">&amp;</span><span class="ident">b</span>)])<span class="question-mark">?</span> {
        <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>)
    } <span class="kw">else</span> {
        <span class="prelude-val">Ok</span>(<span class="bool-val">false</span>)
    }
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">PossibleSolutions</span><span class="op">&lt;</span><span class="ident">V</span>: <span class="ident">Eq</span> <span class="op">+</span> <span class="ident">Hash</span><span class="op">&gt;</span> {
    <span class="doccomment">/// This is exactly the set of possible solutions; there are no others.</span>
    <span class="doccomment">/// Note that an empty set here indicates there are no possible solutions.</span>
    <span class="ident">Exactly</span>(<span class="ident">HashSet</span><span class="op">&lt;</span><span class="ident">V</span><span class="op">&gt;</span>),
    <span class="doccomment">/// All of the solutions in this set are possible solutions, but there</span>
    <span class="doccomment">/// may be others.  That is, there are at least this many solutions.</span>
    <span class="ident">AtLeast</span>(<span class="ident">HashSet</span><span class="op">&lt;</span><span class="ident">V</span><span class="op">&gt;</span>),
}

<span class="kw">impl</span> <span class="ident">PossibleSolutions</span><span class="op">&lt;</span><span class="ident">BVSolution</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Convert a `PossibleSolutions` over `BVSolution` into a</span>
    <span class="doccomment">/// `PossibleSolutions` over `u64`, by applying `as_u64()` to each</span>
    <span class="doccomment">/// `BVSolution`.</span>
    <span class="doccomment">/// If `as_u64()` fails for any individual solution, this returns `None`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">as_u64_solutions</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">PossibleSolutions</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">PossibleSolutions</span>::<span class="ident">Exactly</span>(<span class="ident">v</span>) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">opt</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">bvs</span><span class="op">|</span> <span class="ident">bvs</span>.<span class="ident">as_u64</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">HashSet</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>();
                <span class="ident">opt</span>.<span class="ident">map</span>(<span class="ident">PossibleSolutions</span>::<span class="ident">Exactly</span>)
            },
            <span class="ident">PossibleSolutions</span>::<span class="ident">AtLeast</span>(<span class="ident">v</span>) <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="ident">opt</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">bvs</span><span class="op">|</span> <span class="ident">bvs</span>.<span class="ident">as_u64</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">HashSet</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>();
                <span class="ident">opt</span>.<span class="ident">map</span>(<span class="ident">PossibleSolutions</span>::<span class="ident">AtLeast</span>)
            },
        }
    }
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">SolutionCount</span> {
    <span class="doccomment">/// There are exactly this many solutions</span>
    <span class="ident">Exactly</span>(<span class="ident">usize</span>),
    <span class="doccomment">/// There are at least this many solutions</span>
    <span class="ident">AtLeast</span>(<span class="ident">usize</span>),
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">V</span>: <span class="ident">Eq</span> <span class="op">+</span> <span class="ident">Hash</span><span class="op">&gt;</span> <span class="ident">PossibleSolutions</span><span class="op">&lt;</span><span class="ident">V</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Get a count of how many possible solutions there are.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">count</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">SolutionCount</span> {
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">PossibleSolutions</span>::<span class="ident">Exactly</span>(<span class="ident">v</span>) <span class="op">=&gt;</span> <span class="ident">SolutionCount</span>::<span class="ident">Exactly</span>(<span class="ident">v</span>.<span class="ident">len</span>()),
            <span class="ident">PossibleSolutions</span>::<span class="ident">AtLeast</span>(<span class="ident">v</span>) <span class="op">=&gt;</span> <span class="ident">SolutionCount</span>::<span class="ident">AtLeast</span>(<span class="ident">v</span>.<span class="ident">len</span>()),
        }
    }
}

<span class="doccomment">/// Get a description of the possible solutions for the `BV`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// `n`: Maximum number of distinct solutions to check for.</span>
<span class="doccomment">/// If there are more than `n` possible solutions, this returns a</span>
<span class="doccomment">/// `PossibleSolutions::AtLeast` containing `n+1` solutions.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// These solutions will be disambiguated - see docs on `boolector::BVSolution`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// If there are no possible solutions, this returns `Ok` with an empty</span>
<span class="doccomment">/// `PossibleSolutions`, rather than returning an `Err` with `Error::Unsat`.</span>
<span class="comment">//</span>
<span class="comment">// Also, this function assumes that initially ModelGen is disabled; and it will always disable ModelGen before returning.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_possible_solutions_for_bv</span><span class="op">&lt;</span><span class="ident">V</span>: <span class="ident">BV</span><span class="op">&gt;</span>(<span class="ident">solver</span>: <span class="ident">V</span>::<span class="ident">SolverRef</span>, <span class="ident">bv</span>: <span class="kw-2">&amp;</span><span class="ident">V</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">PossibleSolutions</span><span class="op">&lt;</span><span class="ident">BVSolution</span><span class="op">&gt;&gt;</span> {
    <span class="kw">let</span> <span class="ident">ps</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">n</span> <span class="op">==</span> <span class="number">0</span> {
        <span class="macro">warn</span><span class="macro">!</span>(<span class="string">&quot;A call to get_possible_solutions_for_bv() is resulting in a call to sat() with model generation enabled. Experimentally, these types of calls can be very slow. The BV is {:?}&quot;</span>, <span class="ident">bv</span>);
        <span class="ident">solver</span>.<span class="ident">set_opt</span>(<span class="ident">BtorOption</span>::<span class="ident">ModelGen</span>(<span class="ident">ModelGen</span>::<span class="ident">All</span>));
        <span class="kw">if</span> <span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>)<span class="question-mark">?</span> {
            <span class="ident">PossibleSolutions</span>::<span class="ident">AtLeast</span>(<span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">once</span>(
                <span class="ident">bv</span>.<span class="ident">get_a_solution</span>()<span class="question-mark">?</span>.<span class="ident">disambiguate</span>()  <span class="comment">// a possible solution</span>
            ).<span class="ident">collect</span>())
        } <span class="kw">else</span> {
            <span class="ident">PossibleSolutions</span>::<span class="ident">Exactly</span>(<span class="ident">HashSet</span>::<span class="ident">new</span>())  <span class="comment">// no solutions</span>
        }
    } <span class="kw">else</span> {
        <span class="kw">match</span> <span class="ident">bv</span>.<span class="ident">as_binary_str</span>() {
            <span class="prelude-val">Some</span>(<span class="ident">bstr</span>) <span class="op">=&gt;</span> <span class="ident">PossibleSolutions</span>::<span class="ident">Exactly</span>(
                <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">once</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="ident">bstr</span>)).<span class="ident">collect</span>()
            ),
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">solutions</span> <span class="op">=</span> <span class="ident">HashSet</span>::<span class="ident">new</span>();
                <span class="ident">check_for_common_solutions</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">bv</span>, <span class="ident">n</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">solutions</span>)<span class="question-mark">?</span>;
                <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&gt;</span> <span class="ident">n</span> {
                    <span class="ident">PossibleSolutions</span>::<span class="ident">AtLeast</span>(<span class="ident">solutions</span>)
                } <span class="kw">else</span> {
                    <span class="ident">solver</span>.<span class="ident">push</span>(<span class="number">1</span>);
                    <span class="kw">for</span> <span class="ident">solution</span> <span class="kw">in</span> <span class="ident">solutions</span>.<span class="ident">iter</span>() {
                        <span class="comment">// Temporarily constrain that the solution can&#39;t be `solution` - we want to see if other solutions exist</span>
                        <span class="ident">bv</span>.<span class="ident">_ne</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_binary_str</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">solution</span>.<span class="ident">as_01x_str</span>())).<span class="ident">assert</span>()<span class="question-mark">?</span>;
                    }
                    <span class="macro">warn</span><span class="macro">!</span>(<span class="string">&quot;A call to get_possible_solutions_for_bv() is resulting in a call to sat() with model generation enabled. Experimentally, these types of calls can be very slow. The BV is {:?}&quot;</span>, <span class="ident">bv</span>);
                    <span class="ident">solver</span>.<span class="ident">set_opt</span>(<span class="ident">BtorOption</span>::<span class="ident">ModelGen</span>(<span class="ident">ModelGen</span>::<span class="ident">All</span>));
                    <span class="kw">while</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>)<span class="question-mark">?</span> {
                        <span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">get_a_solution</span>()<span class="question-mark">?</span>.<span class="ident">disambiguate</span>();
                        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">val</span>.<span class="ident">clone</span>());
                        <span class="comment">// Temporarily constrain that the solution can&#39;t be `val`, to see if there is another solution</span>
                        <span class="ident">bv</span>.<span class="ident">_ne</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_binary_str</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">val</span>.<span class="ident">as_01x_str</span>())).<span class="ident">assert</span>()<span class="question-mark">?</span>;
                    }
                    <span class="ident">solver</span>.<span class="ident">pop</span>(<span class="number">1</span>);
                    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&gt;</span> <span class="ident">n</span> {
                        <span class="ident">PossibleSolutions</span>::<span class="ident">AtLeast</span>(<span class="ident">solutions</span>)
                    } <span class="kw">else</span> {
                        <span class="ident">PossibleSolutions</span>::<span class="ident">Exactly</span>(<span class="ident">solutions</span>)
                    }
                }
            },
        }
    };
    <span class="ident">solver</span>.<span class="ident">set_opt</span>(<span class="ident">BtorOption</span>::<span class="ident">ModelGen</span>(<span class="ident">ModelGen</span>::<span class="ident">Disabled</span>));
    <span class="prelude-val">Ok</span>(<span class="ident">ps</span>)
}

<span class="doccomment">/// Check whether some common values are solutions, and if so, add them.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Experimental data shows that calls to `sat()` with ModelGen enabled are _so slow_</span>
<span class="doccomment">/// that it&#39;s worth doing this first to try to avoid them.</span>
<span class="kw">fn</span> <span class="ident">check_for_common_solutions</span><span class="op">&lt;</span><span class="ident">V</span>: <span class="ident">BV</span><span class="op">&gt;</span>(<span class="ident">solver</span>: <span class="ident">V</span>::<span class="ident">SolverRef</span>, <span class="ident">bv</span>: <span class="kw-2">&amp;</span><span class="ident">V</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">solutions</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">HashSet</span><span class="op">&lt;</span><span class="ident">BVSolution</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">width</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">get_width</span>();
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">zero</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="string">&quot;0&quot;</span>.<span class="ident">repeat</span>(<span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">one</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">1</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">1</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">ones</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="string">&quot;1&quot;</span>.<span class="ident">repeat</span>(<span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">1</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">2</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">2</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">2</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">4</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">4</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">3</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">8</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">8</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">4</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">16</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">16</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">5</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">32</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">32</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">6</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">64</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">64</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">7</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">128</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">128</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">8</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">256</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">256</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">9</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">512</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">512</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">10</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">1024</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">1024</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">11</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">2048</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">2048</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="kw">if</span> <span class="ident">solutions</span>.<span class="ident">len</span>() <span class="op">&lt;=</span> <span class="ident">n</span> <span class="op">&amp;&amp;</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">12</span> <span class="op">&amp;&amp;</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u32</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="number">4096</span>, <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="ident">solutions</span>.<span class="ident">insert</span>(<span class="ident">BVSolution</span>::<span class="ident">from_01x_str</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:0width$b}&quot;</span>, <span class="number">4096</span>, <span class="ident">width</span><span class="op">=</span><span class="ident">width</span> <span class="kw">as</span> <span class="ident">usize</span>)));
    }
    <span class="prelude-val">Ok</span>(())
}

<span class="doccomment">/// Get the maximum possible solution for the `BV`: that is, the highest value</span>
<span class="doccomment">/// for which the current set of constraints is still satisfiable.</span>
<span class="doccomment">/// &quot;Maximum&quot; will be interpreted in an unsigned fashion.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Returns `Ok(None)` if there is no solution for the `BV`, that is, if the</span>
<span class="doccomment">/// current set of constraints is unsatisfiable. Only returns `Err` if a solver</span>
<span class="doccomment">/// query itself fails.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">max_possible_solution_for_bv</span><span class="op">&lt;</span><span class="ident">V</span>: <span class="ident">BV</span><span class="op">&gt;</span>(<span class="ident">solver</span>: <span class="ident">V</span>::<span class="ident">SolverRef</span>, <span class="ident">bv</span>: <span class="kw-2">&amp;</span><span class="ident">V</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;&gt;</span> {
    <span class="kw">let</span> <span class="ident">width</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">get_width</span>();
    <span class="kw">if</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">64</span> {
        <span class="macro">unimplemented</span><span class="macro">!</span>(<span class="string">&quot;max_possible_solution_for_bv on a BV with width &gt; 64&quot;</span>);
    }
    <span class="kw">if</span> <span class="op">!</span><span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>)<span class="question-mark">?</span> {
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>);
    }
    <span class="comment">// Shortcut: if the BV is constant, just return its constant value</span>
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">u</span>) <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">as_u64</span>() {
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="ident">u</span>));
    }
    <span class="comment">// Shortcut: check all-ones first, and if it&#39;s a valid solution, just return that</span>
    <span class="kw">if</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">V</span>::<span class="ident">ones</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="kw">if</span> <span class="ident">width</span> <span class="op">==</span> <span class="number">64</span> {
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="ident">std</span>::<span class="ident">u64</span>::<span class="ident">MAX</span>));
        } <span class="kw">else</span> {
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((<span class="number">1</span> <span class="op">&lt;&lt;</span> <span class="ident">width</span>) <span class="op">-</span> <span class="number">1</span>));
        }
    }
    <span class="comment">// min is inclusive, max is exclusive (we know all-ones doesn&#39;t work)</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">min</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">max</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">width</span> <span class="op">==</span> <span class="number">64</span> { <span class="ident">std</span>::<span class="ident">u64</span>::<span class="ident">MAX</span> } <span class="kw">else</span> { (<span class="number">1</span> <span class="op">&lt;&lt;</span> <span class="ident">width</span>) <span class="op">-</span> <span class="number">1</span> };
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">pushes</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">while</span> (<span class="ident">max</span> <span class="op">-</span> <span class="ident">min</span>) <span class="op">&gt;</span> <span class="number">1</span> {
        <span class="kw">let</span> <span class="ident">mid</span> <span class="op">=</span> (<span class="ident">min</span> <span class="op">/</span> <span class="number">2</span>) <span class="op">+</span> (<span class="ident">max</span> <span class="op">/</span> <span class="number">2</span>) <span class="op">+</span> (<span class="ident">min</span> <span class="op">%</span> <span class="number">2</span> <span class="op">+</span> <span class="ident">max</span> <span class="op">%</span> <span class="number">2</span>) <span class="op">/</span> <span class="number">2</span>; <span class="comment">// (min + max) / 2 would be easier, but fails if (min + max) overflows</span>
        <span class="kw">let</span> <span class="ident">mid</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">mid</span> <span class="op">/</span> <span class="number">2</span> <span class="op">&gt;</span> <span class="ident">min</span> { <span class="ident">mid</span> <span class="op">/</span> <span class="number">2</span> } <span class="kw">else</span> { <span class="ident">mid</span> };  <span class="comment">// as another small optimization, rather than checking the midpoint (pure binary search) we bias towards the small end (checking effectively the 25th percentile if min is 0) as we assume small positive numbers are more common, this gets us towards 0 with half the number of solves</span>
        <span class="ident">solver</span>.<span class="ident">push</span>(<span class="number">1</span>);
        <span class="ident">pushes</span> <span class="op">+=</span> <span class="number">1</span>;
        <span class="ident">bv</span>.<span class="ident">ugte</span>(<span class="kw-2">&amp;</span><span class="ident">V</span>::<span class="ident">from_u64</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">mid</span>, <span class="ident">width</span>)).<span class="ident">assert</span>()<span class="question-mark">?</span>;
        <span class="kw">if</span> <span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>)<span class="question-mark">?</span> {
            <span class="ident">min</span> <span class="op">=</span> <span class="ident">mid</span>;
        } <span class="kw">else</span> {
            <span class="ident">max</span> <span class="op">=</span> <span class="ident">mid</span>;
            <span class="ident">solver</span>.<span class="ident">pop</span>(<span class="number">1</span>);
            <span class="ident">pushes</span> <span class="op">-=</span> <span class="number">1</span>;
        }
    }
    <span class="ident">solver</span>.<span class="ident">pop</span>(<span class="ident">pushes</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">max</span> <span class="op">-</span> <span class="ident">min</span>, <span class="number">1</span>);
    <span class="comment">// Recall that min is inclusive, max is exclusive. So `min` is actually the</span>
    <span class="comment">// max possible solution here.</span>
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="ident">min</span>))
}

<span class="doccomment">/// Get the minimum possible solution for the `BV`: that is, the lowest value</span>
<span class="doccomment">/// for which the current set of constraints is still satisfiable.</span>
<span class="doccomment">/// &quot;Minimum&quot; will be interpreted in an unsigned fashion.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Returns `Ok(None)` if there is no solution for the `BV`, that is, if the</span>
<span class="doccomment">/// current set of constraints is unsatisfiable. Only returns `Err` if a solver</span>
<span class="doccomment">/// query itself fails.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">min_possible_solution_for_bv</span><span class="op">&lt;</span><span class="ident">V</span>: <span class="ident">BV</span><span class="op">&gt;</span>(<span class="ident">solver</span>: <span class="ident">V</span>::<span class="ident">SolverRef</span>, <span class="ident">bv</span>: <span class="kw-2">&amp;</span><span class="ident">V</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;&gt;</span> {
    <span class="kw">let</span> <span class="ident">width</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">get_width</span>();
    <span class="kw">if</span> <span class="ident">width</span> <span class="op">&gt;</span> <span class="number">64</span> {
        <span class="macro">unimplemented</span><span class="macro">!</span>(<span class="string">&quot;min_possible_solution_for_bv on a BV with width &gt; 64&quot;</span>);
    }
    <span class="kw">if</span> <span class="op">!</span><span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>)<span class="question-mark">?</span> {
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>);
    }
    <span class="comment">// Shortcut: if the BV is constant, just return its constant value</span>
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">u</span>) <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">as_u64</span>() {
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="ident">u</span>));
    }
    <span class="comment">// Shortcut: check `0` first, and if it&#39;s a valid solution, just return that</span>
    <span class="kw">if</span> <span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>, <span class="ident">bv</span>, <span class="kw-2">&amp;</span><span class="ident">V</span>::<span class="ident">zero</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">width</span>))<span class="question-mark">?</span> {
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>));
    }
    <span class="comment">// min is exclusive (we know `0` doesn&#39;t work), max is inclusive</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">min</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">max</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">width</span> <span class="op">==</span> <span class="number">64</span> { <span class="ident">std</span>::<span class="ident">u64</span>::<span class="ident">MAX</span> } <span class="kw">else</span> { (<span class="number">1</span> <span class="op">&lt;&lt;</span> <span class="ident">width</span>) <span class="op">-</span> <span class="number">1</span> };
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">pushes</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">while</span> (<span class="ident">max</span> <span class="op">-</span> <span class="ident">min</span>) <span class="op">&gt;</span> <span class="number">1</span> {
        <span class="kw">let</span> <span class="ident">mid</span> <span class="op">=</span> (<span class="ident">min</span> <span class="op">/</span> <span class="number">2</span>) <span class="op">+</span> (<span class="ident">max</span> <span class="op">/</span> <span class="number">2</span>) <span class="op">+</span> (<span class="ident">min</span> <span class="op">%</span> <span class="number">2</span> <span class="op">+</span> <span class="ident">max</span> <span class="op">%</span> <span class="number">2</span>) <span class="op">/</span> <span class="number">2</span>; <span class="comment">// (min + max) / 2 would be easier, but fails if (min + max) overflows</span>
        <span class="kw">let</span> <span class="ident">mid</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">mid</span> <span class="op">/</span> <span class="number">2</span> <span class="op">&gt;</span> <span class="ident">min</span> { <span class="ident">mid</span> <span class="op">/</span> <span class="number">2</span> } <span class="kw">else</span> { <span class="ident">mid</span> };  <span class="comment">// as another small optimization, rather than checking the midpoint (pure binary search) we bias towards the small end (checking effectively the 25th percentile if min is 0) as we assume small positive numbers are more common, this gets us towards 0 with half the number of solves</span>
        <span class="ident">solver</span>.<span class="ident">push</span>(<span class="number">1</span>);
        <span class="ident">pushes</span> <span class="op">+=</span> <span class="number">1</span>;
        <span class="ident">bv</span>.<span class="ident">ulte</span>(<span class="kw-2">&amp;</span><span class="ident">V</span>::<span class="ident">from_u64</span>(<span class="ident">solver</span>.<span class="ident">clone</span>(), <span class="ident">mid</span>, <span class="ident">width</span>)).<span class="ident">assert</span>()<span class="question-mark">?</span>;
        <span class="kw">if</span> <span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">solver</span>)<span class="question-mark">?</span> {
            <span class="ident">max</span> <span class="op">=</span> <span class="ident">mid</span>;
        } <span class="kw">else</span> {
            <span class="ident">min</span> <span class="op">=</span> <span class="ident">mid</span>;
            <span class="ident">solver</span>.<span class="ident">pop</span>(<span class="number">1</span>);
            <span class="ident">pushes</span> <span class="op">-=</span> <span class="number">1</span>;
        }
    }
    <span class="ident">solver</span>.<span class="ident">pop</span>(<span class="ident">pushes</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">max</span> <span class="op">-</span> <span class="ident">min</span>, <span class="number">1</span>);
    <span class="comment">// Recall that min is exclusive, max is inclusive. So `max` is actually the</span>
    <span class="comment">// min possible solution here.</span>
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="ident">max</span>))
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
    <span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;
    <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">backend</span>::<span class="ident">SolverRef</span>;
    <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">rc</span>::<span class="ident">Rc</span>;

    <span class="kw">type</span> <span class="ident">BV</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">BV</span>;

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">basic_sat</span>() {
        <span class="kw">let</span> <span class="ident">btor</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">new</span>();

        <span class="comment">// fresh btor should be sat</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>));

        <span class="comment">// adding True constraint should still be sat</span>
        <span class="ident">BV</span>::<span class="ident">from_bool</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="bool-val">true</span>).<span class="ident">assert</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>));

        <span class="comment">// adding x &gt; 0 constraint should still be sat</span>
        <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">BV</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">new</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;x&quot;</span>));
        <span class="ident">x</span>.<span class="ident">sgt</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">zero</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>)).<span class="ident">assert</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>));
    }

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">basic_unsat</span>() {
        <span class="kw">let</span> <span class="ident">btor</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">new</span>();

        <span class="comment">// adding False constraint should be unsat</span>
        <span class="ident">BV</span>::<span class="ident">from_bool</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="bool-val">false</span>).<span class="ident">assert</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">false</span>));
    }

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">extra_constraints</span>() {
        <span class="kw">let</span> <span class="ident">btor</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">new</span>();

        <span class="comment">// adding x &gt; 3 constraint should still be sat</span>
        <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">BV</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">new</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;x&quot;</span>));
        <span class="ident">x</span>.<span class="ident">ugt</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">3</span>, <span class="number">64</span>)).<span class="ident">assert</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>));

        <span class="comment">// adding x &lt; 3 constraint should make us unsat</span>
        <span class="kw">let</span> <span class="ident">bad_constraint</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">ult</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">3</span>, <span class="number">64</span>));
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sat_with_extra_constraints</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>, <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">once</span>(<span class="kw-2">&amp;</span><span class="ident">bad_constraint</span>)), <span class="prelude-val">Ok</span>(<span class="bool-val">false</span>));

        <span class="comment">// the solver itself should still be sat, extra constraints weren&#39;t permanently added</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sat</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>));
    }

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">can_or_must_be_equal</span>() {
        <span class="kw">let</span> <span class="ident">btor</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">new</span>();

        <span class="comment">// create constants 2, 3, 4, 5, and 7, which we&#39;ll need</span>
        <span class="kw">let</span> <span class="ident">two</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">2</span>, <span class="number">64</span>);
        <span class="kw">let</span> <span class="ident">three</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">3</span>, <span class="number">64</span>);
        <span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">4</span>, <span class="number">64</span>);
        <span class="kw">let</span> <span class="ident">five</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">5</span>, <span class="number">64</span>);
        <span class="kw">let</span> <span class="ident">seven</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">7</span>, <span class="number">64</span>);

        <span class="comment">// add an x &gt; 3 constraint</span>
        <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">BV</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">new</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;x&quot;</span>));
        <span class="ident">x</span>.<span class="ident">ugt</span>(<span class="kw-2">&amp;</span><span class="ident">three</span>).<span class="ident">assert</span>();

        <span class="comment">// we should have that x _can be_ 7 but not _must be_ 7</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>, <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="ident">seven</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>));
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bvs_must_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>, <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="ident">seven</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">false</span>));

        <span class="comment">// we should have that x neither _can be_ nor _must be_ 2</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>, <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="ident">two</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">false</span>));
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bvs_must_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>, <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="ident">two</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">false</span>));

        <span class="comment">// add an x &lt; 5 constraint</span>
        <span class="ident">x</span>.<span class="ident">ult</span>(<span class="kw-2">&amp;</span><span class="ident">five</span>).<span class="ident">assert</span>();

        <span class="comment">// we should now have that x both _can be_ and _must be_ 4</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bvs_can_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>, <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="ident">four</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>));
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bvs_must_be_equal</span>(<span class="kw-2">&amp;</span><span class="ident">btor</span>, <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="ident">four</span>), <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>));
    }

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">possible_solutions</span>() {
        <span class="kw">let</span> <span class="ident">btor</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">new</span>();

        <span class="comment">// add x &gt; 3 constraint</span>
        <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">BV</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">new</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;x&quot;</span>));
        <span class="ident">x</span>.<span class="ident">ugt</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">3</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// check that there are more than 2 solutions</span>
        <span class="kw">let</span> <span class="ident">num_solutions</span> <span class="op">=</span> <span class="ident">get_possible_solutions_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="number">2</span>).<span class="ident">unwrap</span>().<span class="ident">count</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">num_solutions</span>, <span class="ident">SolutionCount</span>::<span class="ident">AtLeast</span>(<span class="number">3</span>));

        <span class="comment">// add x &lt; 6 constraint</span>
        <span class="ident">x</span>.<span class="ident">ult</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">6</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// check that there are now exactly two solutions</span>
        <span class="kw">let</span> <span class="ident">solutions</span> <span class="op">=</span> <span class="ident">get_possible_solutions_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="number">2</span>).<span class="ident">unwrap</span>().<span class="ident">as_u64_solutions</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">solutions</span>, <span class="prelude-val">Some</span>(<span class="ident">PossibleSolutions</span>::<span class="ident">Exactly</span>([<span class="number">4</span>,<span class="number">5</span>].<span class="ident">into_iter</span>().<span class="ident">copied</span>().<span class="ident">collect</span>())));

        <span class="comment">// add x &lt; 5 constraint</span>
        <span class="ident">x</span>.<span class="ident">ult</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">5</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// check that there is now exactly one solution</span>
        <span class="kw">let</span> <span class="ident">solutions</span> <span class="op">=</span> <span class="ident">get_possible_solutions_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="number">2</span>).<span class="ident">unwrap</span>().<span class="ident">as_u64_solutions</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">solutions</span>, <span class="prelude-val">Some</span>(<span class="ident">PossibleSolutions</span>::<span class="ident">Exactly</span>(<span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">once</span>(<span class="number">4</span>).<span class="ident">collect</span>())));

        <span class="comment">// add x &lt; 3 constraint</span>
        <span class="ident">x</span>.<span class="ident">ult</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">3</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// check that there are now no solutions</span>
        <span class="kw">let</span> <span class="ident">solutions</span> <span class="op">=</span> <span class="ident">get_possible_solutions_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="number">2</span>).<span class="ident">unwrap</span>().<span class="ident">as_u64_solutions</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">solutions</span>, <span class="prelude-val">Some</span>(<span class="ident">PossibleSolutions</span>::<span class="ident">Exactly</span>(<span class="ident">HashSet</span>::<span class="ident">new</span>())));
    }

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">min_possible_solution</span>() {
        <span class="kw">let</span> <span class="ident">btor</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">new</span>();

        <span class="comment">// add x &gt; 3 constraint</span>
        <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">BV</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">new</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;x&quot;</span>));
        <span class="ident">x</span>.<span class="ident">ugt</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">3</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// min possible solution should be 4</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">min_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>)));

        <span class="comment">// add x &lt; 6 constraint</span>
        <span class="ident">x</span>.<span class="ident">ult</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">6</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// min possible solution should still be 4</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">min_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>)));

        <span class="comment">// add x &lt; 3 constraint</span>
        <span class="ident">x</span>.<span class="ident">ult</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">3</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// min_possible_solution_for_bv should now return None</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">min_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));
    }

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">max_possible_solution</span>() {
        <span class="kw">let</span> <span class="ident">btor</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">new</span>();

        <span class="comment">// add x &lt; 7 constraint</span>
        <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">BV</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">new</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;x&quot;</span>));
        <span class="ident">x</span>.<span class="ident">ult</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">7</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// max possible solution should be 6</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">max_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="number">6</span>)));

        <span class="comment">// but min possible solution should be 0</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">min_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>)));

        <span class="comment">// add x &gt; 3 constraint</span>
        <span class="ident">x</span>.<span class="ident">ugt</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">3</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// max possible solution should still be 6</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">max_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="number">6</span>)));

        <span class="comment">// and min possible solution should now be 4</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">min_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>)));

        <span class="comment">// add x &gt; 7 constraint</span>
        <span class="ident">x</span>.<span class="ident">ugt</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">7</span>, <span class="number">64</span>)).<span class="ident">assert</span>();

        <span class="comment">// max_possible_solution_for_bv should now return None</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">max_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));
    }

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">min_possible_solution_overflow</span>() {
        <span class="kw">let</span> <span class="ident">btor</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">new</span>();

        <span class="comment">// Constrain x so that -2 and -1 are the only possible solutions. This</span>
        <span class="comment">// means that the min possible _unsigned_ solution will be 0b1111...1110</span>
        <span class="comment">// (that is, -2 if we interpreted it as signed).</span>
        <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">BV</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">new</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;x&quot;</span>));
        <span class="kw">let</span> <span class="ident">zero</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">zero</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>);
        <span class="ident">x</span>.<span class="ident">slt</span>(<span class="kw-2">&amp;</span><span class="ident">zero</span>).<span class="ident">assert</span>();
        <span class="kw">let</span> <span class="ident">minustwo</span> <span class="op">=</span> <span class="ident">zero</span>.<span class="ident">sub</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">2</span>, <span class="number">64</span>));
        <span class="ident">x</span>.<span class="ident">sgte</span>(<span class="kw-2">&amp;</span><span class="ident">minustwo</span>).<span class="ident">assert</span>();

        <span class="comment">// The min possible (unsigned) solution should be -2</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">min_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((<span class="op">-</span><span class="number">2_i64</span>) <span class="kw">as</span> <span class="ident">u64</span>)));
    }

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">max_possible_solution_overflow</span>() {
        <span class="kw">let</span> <span class="ident">btor</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Btor</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">SolverRef</span><span class="op">&gt;</span>::<span class="ident">new</span>();

        <span class="comment">// Constrain x so that -2 is a solution but -1 is not. This means that the max possible</span>
        <span class="comment">// _unsigned_ solution will be 0b1111...1110 (that is, -2 if we interpreted it as signed).</span>
        <span class="kw">let</span> <span class="ident">x</span>: <span class="ident">BV</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">new</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;x&quot;</span>));
        <span class="kw">let</span> <span class="ident">minustwo</span> <span class="op">=</span> <span class="ident">BV</span>::<span class="ident">zero</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">64</span>).<span class="ident">sub</span>(<span class="kw-2">&amp;</span><span class="ident">BV</span>::<span class="ident">from_u64</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="number">2</span>, <span class="number">64</span>));
        <span class="ident">x</span>.<span class="ident">slte</span>(<span class="kw-2">&amp;</span><span class="ident">minustwo</span>).<span class="ident">assert</span>();

        <span class="comment">// The max possible (unsigned) solution should be -2</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">max_possible_solution_for_bv</span>(<span class="ident">btor</span>.<span class="ident">clone</span>(), <span class="kw-2">&amp;</span><span class="ident">x</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((<span class="op">-</span><span class="number">2_i64</span>) <span class="kw">as</span> <span class="ident">u64</span>)));
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "haybale";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>