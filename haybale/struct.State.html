<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `State` struct in crate `haybale`."><meta name="keywords" content="rust, rustlang, rust-lang, State"><title>haybale::State - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../haybale/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Struct State</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#fields">Fields</a><div class="sidebar-links"><a href="#structfield.config">config</a><a href="#structfield.cur_loc">cur_loc</a><a href="#structfield.proj">proj</a><a href="#structfield.solver">solver</a></div><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.add_mem_watchpoint">add_mem_watchpoint</a><a href="#method.all_vars_in_cur_fn">all_vars_in_cur_fn</a><a href="#method.allocate">allocate</a><a href="#method.assign_bv_to_name">assign_bv_to_name</a><a href="#method.bv_from_bool">bv_from_bool</a><a href="#method.bv_from_i32">bv_from_i32</a><a href="#method.bv_from_i64">bv_from_i64</a><a href="#method.bv_from_u32">bv_from_u32</a><a href="#method.bv_from_u64">bv_from_u64</a><a href="#method.bvs_can_be_equal">bvs_can_be_equal</a><a href="#method.bvs_must_be_equal">bvs_must_be_equal</a><a href="#method.const_to_bv">const_to_bv</a><a href="#method.count_backtracking_points">count_backtracking_points</a><a href="#method.current_assignments_as_pretty_string">current_assignments_as_pretty_string</a><a href="#method.current_callstack_depth">current_callstack_depth</a><a href="#method.demangle">demangle</a><a href="#method.disable_watchpoint">disable_watchpoint</a><a href="#method.enable_watchpoint">enable_watchpoint</a><a href="#method.fork">fork</a><a href="#method.fp_size">fp_size</a><a href="#method.fp_size_in_bits">fp_size_in_bits</a><a href="#method.full_error_message_with_context">full_error_message_with_context</a><a href="#method.get_a_solution_for_bv">get_a_solution_for_bv</a><a href="#method.get_a_solution_for_irname">get_a_solution_for_irname</a><a href="#method.get_allocation_size">get_allocation_size</a><a href="#method.get_bv_by_irname">get_bv_by_irname</a><a href="#method.get_func_by_name">get_func_by_name</a><a href="#method.get_offset_bv_index">get_offset_bv_index</a><a href="#method.get_offset_constant_index">get_offset_constant_index</a><a href="#method.get_path">get_path</a><a href="#method.get_path_length">get_path_length</a><a href="#method.get_pointer_to_function">get_pointer_to_function</a><a href="#method.get_pointer_to_function_hook">get_pointer_to_function_hook</a><a href="#method.get_possible_solutions_for_bv">get_possible_solutions_for_bv</a><a href="#method.get_possible_solutions_for_irname">get_possible_solutions_for_irname</a><a href="#method.max_possible_solution_for_bv_as_u64">max_possible_solution_for_bv_as_u64</a><a href="#method.max_possible_solution_for_irname_as_u64">max_possible_solution_for_irname_as_u64</a><a href="#method.min_possible_solution_for_bv_as_u64">min_possible_solution_for_bv_as_u64</a><a href="#method.min_possible_solution_for_irname_as_u64">min_possible_solution_for_irname_as_u64</a><a href="#method.new">new</a><a href="#method.new_bv_with_name">new_bv_with_name</a><a href="#method.one">one</a><a href="#method.ones">ones</a><a href="#method.operand_to_bv">operand_to_bv</a><a href="#method.overwrite_latest_version_of_bv">overwrite_latest_version_of_bv</a><a href="#method.pop_callsite">pop_callsite</a><a href="#method.pretty_backtrace">pretty_backtrace</a><a href="#method.pretty_path_interleaved">pretty_path_interleaved</a><a href="#method.pretty_path_llvm">pretty_path_llvm</a><a href="#method.pretty_path_llvm_instructions">pretty_path_llvm_instructions</a><a href="#method.pretty_path_source">pretty_path_source</a><a href="#method.push_callsite">push_callsite</a><a href="#method.push_invokesite">push_invokesite</a><a href="#method.read">read</a><a href="#method.record_bv_result">record_bv_result</a><a href="#method.record_path_entry">record_path_entry</a><a href="#method.revert_to_backtracking_point">revert_to_backtracking_point</a><a href="#method.rm_mem_watchpoint">rm_mem_watchpoint</a><a href="#method.sat">sat</a><a href="#method.sat_with_extra_constraints">sat_with_extra_constraints</a><a href="#method.save_backtracking_point">save_backtracking_point</a><a href="#method.size">size</a><a href="#method.size_in_bits">size_in_bits</a><a href="#method.size_opaque_aware">size_opaque_aware</a><a href="#method.type_of">type_of</a><a href="#method.write">write</a><a href="#method.zero">zero</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class="location"><a href="index.html">haybale</a></p><div id="sidebar-vars" data-name="State" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="index.html">haybale</a>::<wbr><a class="struct" href="">State</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/haybale/state.rs.html#37-96" title="goto source code">[src]</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust struct">pub struct State&lt;'p, B:&nbsp;<a class="trait" href="../haybale/backend/trait.Backend.html" title="trait haybale::backend::Backend">Backend</a>&gt; {
    pub solver: B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.SolverRef" title="type haybale::backend::Backend::SolverRef">SolverRef</a>,
    pub config: <a class="struct" href="../haybale/config/struct.Config.html" title="struct haybale::config::Config">Config</a>&lt;'p, B&gt;,
    pub proj: &amp;'p <a class="struct" href="../haybale/struct.Project.html" title="struct haybale::Project">Project</a>,
    pub cur_loc: <a class="struct" href="../haybale/struct.Location.html" title="struct haybale::Location">Location</a>&lt;'p&gt;,
    // some fields omitted
}</pre></div><div class="docblock"><p>A <code>State</code> describes the full program state at a given moment during symbolic
execution.</p>
</div><h2 id="fields" class="fields small-section-header">
                       Fields<a href="#fields" class="anchor"></a></h2><span id="structfield.solver" class="structfield small-section-header"><a href="#structfield.solver" class="anchor field"></a><code>solver: B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.SolverRef" title="type haybale::backend::Backend::SolverRef">SolverRef</a></code></span><div class="docblock"><p>Reference to the solver instance being used</p>
</div><span id="structfield.config" class="structfield small-section-header"><a href="#structfield.config" class="anchor field"></a><code>config: <a class="struct" href="../haybale/config/struct.Config.html" title="struct haybale::config::Config">Config</a>&lt;'p, B&gt;</code></span><div class="docblock"><p>The configuration being used</p>
</div><span id="structfield.proj" class="structfield small-section-header"><a href="#structfield.proj" class="anchor field"></a><code>proj: &amp;'p <a class="struct" href="../haybale/struct.Project.html" title="struct haybale::Project">Project</a></code></span><div class="docblock"><p>Referece to the <code>Project</code> being used</p>
</div><span id="structfield.cur_loc" class="structfield small-section-header"><a href="#structfield.cur_loc" class="anchor field"></a><code>cur_loc: <a class="struct" href="../haybale/struct.Location.html" title="struct haybale::Location">Location</a>&lt;'p&gt;</code></span><div class="docblock"><p>Indicates the instruction which is currently being executed</p>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><h3 id="impl" class="impl"><code class="in-band">impl&lt;'p, B:&nbsp;<a class="trait" href="../haybale/backend/trait.Backend.html" title="trait haybale::backend::Backend">Backend</a>&gt; <a class="struct" href="../haybale/struct.State.html" title="struct haybale::State">State</a>&lt;'p, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: 'p,&nbsp;</span></code><a href="#impl" class="anchor"></a><a class="srclink" href="../src/haybale/state.rs.html#392-2272" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.new" class="method"><code>pub fn <a href="#method.new" class="fnname">new</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;project: &amp;'p <a class="struct" href="../haybale/struct.Project.html" title="struct haybale::Project">Project</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;start_loc: <a class="struct" href="../haybale/struct.Location.html" title="struct haybale::Location">Location</a>&lt;'p&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;config: <a class="struct" href="../haybale/config/struct.Config.html" title="struct haybale::config::Config">Config</a>&lt;'p, B&gt;<br>) -&gt; Self</code><a class="srclink" href="../src/haybale/state.rs.html#399-574" title="goto source code">[src]</a></h4><div class="docblock"><p><code>start_loc</code>: the <code>Location</code> where the <code>State</code> should begin executing.
As of this writing, <code>start_loc</code> should be the entry point of a
function, or you will have problems.</p>
</div><h4 id="method.fork" class="method"><code>pub fn <a href="#method.fork" class="fnname">fork</a>(&amp;self) -&gt; Self</code><a class="srclink" href="../src/haybale/state.rs.html#580-588" title="goto source code">[src]</a></h4><div class="docblock"><p>Fully duplicate the <code>State</code>. Unlike with <code>clone()</code>, the <code>State</code> this
function returns will have a fully separate (fully duplicated) solver
instance. (With <code>clone()</code>, the states will still share references to the
same solver instance.)</p>
</div><h4 id="method.sat" class="method"><code>pub fn <a href="#method.sat" class="fnname">sat</a>(&amp;self) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#593-595" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if current constraints are satisfiable, <code>false</code> if not.</p>
<p>Returns <code>Error::SolverError</code> if the query failed (e.g., was interrupted or timed out).</p>
</div><h4 id="method.sat_with_extra_constraints" class="method"><code>pub fn <a href="#method.sat_with_extra_constraints" class="fnname">sat_with_extra_constraints</a>&lt;'b&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'b self, <br>&nbsp;&nbsp;&nbsp;&nbsp;constraints: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = &amp;'b B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>&gt;<br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#603-608" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if the current constraints plus the given additional constraints
are together satisfiable, or <code>false</code> if not.</p>
<p>Returns <code>Error::SolverError</code> if the query failed (e.g., was interrupted or timed out).</p>
<p>Does not permanently add the given constraints to the solver.</p>
</div><h4 id="method.get_bv_by_irname" class="method"><code>pub fn <a href="#method.get_bv_by_irname" class="fnname">get_bv_by_irname</a>&lt;'s&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'s self, <br>&nbsp;&nbsp;&nbsp;&nbsp;funcname: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;name: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a><br>) -&gt; &amp;'s B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#617-619" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the <code>BV</code> corresponding to the given IR <code>Name</code> (from the given
<code>Function</code> name).</p>
<p>There should already have been a <code>BV</code> created for this <code>Name</code> on this
path; this won't attempt to create a <code>BV</code> if there isn't already one for
this <code>Name</code>.</p>
</div><h4 id="method.bvs_must_be_equal" class="method"><code>pub fn <a href="#method.bvs_must_be_equal" class="fnname">bvs_must_be_equal</a>(&amp;self, a: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>, b: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#634-636" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if under the current constraints, <code>a</code> and <code>b</code> must have the
same value. Returns <code>false</code> if <code>a</code> and <code>b</code> may have different values. (If the
current constraints are themselves unsatisfiable, that will result in
<code>true</code>.)</p>
<p>A common use case for this function is to test whether some <code>BV</code> must be
equal to a given concrete value. You can do this with something like
<code>state.bvs_must_be_equal(bv, &amp;state.bv_from_u64(...))</code>.</p>
<p>This function and <code>bvs_can_be_equal()</code> are both more efficient than
<code>get_a_solution()</code> or <code>get_possible_solutions()</code>-type functions, as they do
not require full model generation. You should prefer this function or
<code>bvs_can_be_equal()</code> if they are sufficient for your needs.</p>
</div><h4 id="method.bvs_can_be_equal" class="method"><code>pub fn <a href="#method.bvs_can_be_equal" class="fnname">bvs_can_be_equal</a>(&amp;self, a: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>, b: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#651-653" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if under the current constraints, <code>a</code> and <code>b</code> can have the
same value. Returns <code>false</code> if <code>a</code> and <code>b</code> cannot have the same value. (If
the current constraints are themselves unsatisfiable, that will also result
in <code>false</code>.)</p>
<p>A common use case for this function is to test whether some <code>BV</code> can be
equal to a given concrete value. You can do this with something like
<code>state.bvs_can_be_equal(bv, &amp;state.bv_from_u64(...))</code>.</p>
<p>This function and <code>bvs_must_be_equal()</code> are both more efficient than
<code>get_a_solution()</code> or <code>get_possible_solutions()</code>-type functions, as they do
not require full model generation. You should prefer this function or
<code>bvs_must_be_equal()</code> if they are sufficient for your needs.</p>
</div><h4 id="method.get_a_solution_for_bv" class="method"><code>pub fn <a href="#method.get_a_solution_for_bv" class="fnname">get_a_solution_for_bv</a>(&amp;self, bv: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/boolector/0.4.2/boolector/node/struct.BVSolution.html" title="struct boolector::node::BVSolution">BVSolution</a>&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#657-674" title="goto source code">[src]</a></h4><div class="docblock"><p>Get one possible concrete value for the <code>BV</code>.
Returns <code>Ok(None)</code> if no possible solution, or <code>Error::SolverError</code> if the solver query failed.</p>
</div><h4 id="method.get_a_solution_for_irname" class="method"><code>pub fn <a href="#method.get_a_solution_for_irname" class="fnname">get_a_solution_for_irname</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;funcname: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;name: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/boolector/0.4.2/boolector/node/struct.BVSolution.html" title="struct boolector::node::BVSolution">BVSolution</a>&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#679-686" title="goto source code">[src]</a></h4><div class="docblock"><p>Get one possible concrete value for the given IR <code>Name</code> (from the given <code>Function</code> name).
Returns <code>Ok(None)</code> if no possible solution, or <code>Error::SolverError</code> if the solver query failed.</p>
</div><h4 id="method.get_possible_solutions_for_bv" class="method"><code>pub fn <a href="#method.get_possible_solutions_for_bv" class="fnname">get_possible_solutions_for_bv</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;bv: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="enum" href="../haybale/solver_utils/enum.PossibleSolutions.html" title="enum haybale::solver_utils::PossibleSolutions">PossibleSolutions</a>&lt;<a class="struct" href="https://docs.rs/boolector/0.4.2/boolector/node/struct.BVSolution.html" title="struct boolector::node::BVSolution">BVSolution</a>&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#698-704" title="goto source code">[src]</a></h4><div class="docblock"><p>Get a description of the possible solutions for the <code>BV</code>.</p>
<p><code>n</code>: Maximum number of distinct solutions to check for.
If there are more than <code>n</code> possible solutions, this returns a
<code>PossibleSolutions::AtLeast</code> containing <code>n+1</code> solutions.</p>
<p>These solutions will be disambiguated - see docs on <code>boolector::BVSolution</code>.</p>
<p>If there are no possible solutions, this returns <code>Ok</code> with an empty
<code>PossibleSolutions</code>, rather than returning an <code>Err</code> with <code>Error::Unsat</code>.</p>
</div><h4 id="method.get_possible_solutions_for_irname" class="method"><code>pub fn <a href="#method.get_possible_solutions_for_irname" class="fnname">get_possible_solutions_for_irname</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;funcname: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;name: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="enum" href="../haybale/solver_utils/enum.PossibleSolutions.html" title="enum haybale::solver_utils::PossibleSolutions">PossibleSolutions</a>&lt;<a class="struct" href="https://docs.rs/boolector/0.4.2/boolector/node/struct.BVSolution.html" title="struct boolector::node::BVSolution">BVSolution</a>&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#717-725" title="goto source code">[src]</a></h4><div class="docblock"><p>Get a description of the possible solutions for the given IR <code>Name</code> (from the given <code>Function</code> name).</p>
<p><code>n</code>: Maximum number of distinct solutions to check for.
If there are more than <code>n</code> possible solutions, this returns a
<code>PossibleSolutions::AtLeast</code> containing <code>n+1</code> solutions.</p>
<p>These solutions will be disambiguated - see docs on <code>boolector::BVSolution</code>.</p>
<p>If there are no possible solutions, this returns <code>Ok</code> with an empty
<code>PossibleSolutions</code>, rather than returning an <code>Err</code> with <code>Error::Unsat</code>.</p>
</div><h4 id="method.max_possible_solution_for_bv_as_u64" class="method"><code>pub fn <a href="#method.max_possible_solution_for_bv_as_u64" class="fnname">max_possible_solution_for_bv_as_u64</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;bv: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#734-736" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the maximum possible solution for the <code>BV</code>: that is, the highest value
for which the current set of constraints is still satisfiable.
&quot;Maximum&quot; will be interpreted in an unsigned fashion.</p>
<p>Returns <code>Ok(None)</code> if there is no solution for the <code>BV</code>, that is, if the
current set of constraints is unsatisfiable. Only returns <code>Err</code> if a solver
query itself fails. Panics if the <code>BV</code> is wider than 64 bits.</p>
</div><h4 id="method.max_possible_solution_for_irname_as_u64" class="method"><code>pub fn <a href="#method.max_possible_solution_for_irname_as_u64" class="fnname">max_possible_solution_for_irname_as_u64</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;funcname: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;name: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#747-754" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the maximum possible solution for the given IR <code>Name</code> (from the given
<code>Function</code> name): that is, the highest value for which the current set of
constraints is still satisfiable.
&quot;Maximum&quot; will be interpreted in an unsigned fashion.</p>
<p>Returns <code>Ok(None)</code> if there is no solution for the <code>BV</code>, that is, if the
current set of constraints is unsatisfiable. Only returns <code>Err</code> if a solver
query itself fails. Panics if the <code>BV</code> is wider than 64 bits.</p>
</div><h4 id="method.min_possible_solution_for_bv_as_u64" class="method"><code>pub fn <a href="#method.min_possible_solution_for_bv_as_u64" class="fnname">min_possible_solution_for_bv_as_u64</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;bv: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#763-765" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the minimum possible solution for the <code>BV</code>: that is, the lowest value
for which the current set of constraints is still satisfiable.
&quot;Minimum&quot; will be interpreted in an unsigned fashion.</p>
<p>Returns <code>Ok(None)</code> if there is no solution for the <code>BV</code>, that is, if the
current set of constraints is unsatisfiable. Only returns <code>Err</code> if a solver
query itself fails. Panics if the <code>BV</code> is wider than 64 bits.</p>
</div><h4 id="method.min_possible_solution_for_irname_as_u64" class="method"><code>pub fn <a href="#method.min_possible_solution_for_irname_as_u64" class="fnname">min_possible_solution_for_irname_as_u64</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;funcname: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;name: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#776-783" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the minimum possible solution for the given IR <code>Name</code> (from the given
<code>Function</code> name): that is, the lowest value for which the current set of
constraints is still satisfiable.
&quot;Minimum&quot; will be interpreted in an unsigned fashion.</p>
<p>Returns <code>Ok(None)</code> if there is no solution for the <code>BV</code>, that is, if the
current set of constraints is unsatisfiable. Only returns <code>Err</code> if a solver
query itself fails. Panics if the <code>BV</code> is wider than 64 bits.</p>
</div><h4 id="method.bv_from_bool" class="method"><code>pub fn <a href="#method.bv_from_bool" class="fnname">bv_from_bool</a>(&amp;self, b: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#789-791" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a <code>BV</code> constant representing the given <code>bool</code> (either constant
<code>true</code> or constant <code>false</code>).
The resulting <code>BV</code> will be either constant <code>0</code> or constant <code>1</code>, and will
have bitwidth <code>1</code>.</p>
</div><h4 id="method.bv_from_i32" class="method"><code>pub fn <a href="#method.bv_from_i32" class="fnname">bv_from_i32</a>(&amp;self, i: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, width: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#795-797" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a <code>BV</code> representing the given constant <code>i32</code> value, with the given
bitwidth.</p>
</div><h4 id="method.bv_from_u32" class="method"><code>pub fn <a href="#method.bv_from_u32" class="fnname">bv_from_u32</a>(&amp;self, u: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, width: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#801-803" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a <code>BV</code> representing the given constant <code>u32</code> value, with the given
bitwidth.</p>
</div><h4 id="method.bv_from_i64" class="method"><code>pub fn <a href="#method.bv_from_i64" class="fnname">bv_from_i64</a>(&amp;self, i: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>, width: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#807-809" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a <code>BV</code> representing the given constant <code>i64</code> value, with the given
bitwidth.</p>
</div><h4 id="method.bv_from_u64" class="method"><code>pub fn <a href="#method.bv_from_u64" class="fnname">bv_from_u64</a>(&amp;self, u: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>, width: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#813-815" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a <code>BV</code> representing the given constant <code>u64</code> value, with the given
bitwidth.</p>
</div><h4 id="method.zero" class="method"><code>pub fn <a href="#method.zero" class="fnname">zero</a>(&amp;self, width: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#820-822" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a <code>BV</code> representing the constant <code>0</code> of the given bitwidth.
This is equivalent to <code>self.bv_from_i32(0, width)</code> but may be more
efficient.</p>
</div><h4 id="method.one" class="method"><code>pub fn <a href="#method.one" class="fnname">one</a>(&amp;self, width: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#827-829" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a <code>BV</code> representing the constant <code>1</code> of the given bitwidth.
This is equivalent to <code>self.bv_from_i32(1, width)</code> but may be more
efficient.</p>
</div><h4 id="method.ones" class="method"><code>pub fn <a href="#method.ones" class="fnname">ones</a>(&amp;self, width: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#834-836" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a <code>BV</code> constant of the given width, where all bits are set to one.
This is equivalent to <code>self.bv_from_i32(-1, width)</code> but may be more
efficient.</p>
</div><h4 id="method.new_bv_with_name" class="method"><code>pub fn <a href="#method.new_bv_with_name" class="fnname">new_bv_with_name</a>(&amp;mut self, name: <a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a>, bits: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#851-854" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a new (unconstrained) <code>BV</code> for the given <code>Name</code> (in the current function).</p>
<p>This function performs uniquing, so if you call it twice
with the same <code>Name</code>-<code>Function</code> pair, you will get two different <code>BV</code>s.</p>
<p>Returns the new <code>BV</code>, or <code>Err</code> if it can't be created.</p>
<p>(As of this writing, the only <code>Err</code> that might be returned is
<code>Error::LoopBoundExceeded</code>, which is returned if creating the new <code>BV</code>
would exceed <code>max_versions_of_name</code> -- see
<a href="struct.Config.html"><code>Config</code></a>.)</p>
<p>Also, we assume that no two <code>Function</code>s share the same name.</p>
</div><h4 id="method.assign_bv_to_name" class="method"><code>pub fn <a href="#method.assign_bv_to_name" class="fnname">assign_bv_to_name</a>(&amp;mut self, name: <a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a>, bv: B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#868-871" title="goto source code">[src]</a></h4><div class="docblock"><p>Assign the given <code>BV</code> to the given <code>Name</code> (in the current function).</p>
<p>This function performs uniquing, so it creates a new version of the
variable represented by the <code>(String, Name)</code> pair rather than overwriting
the current version.</p>
<p>Returns <code>Err</code> if the assignment can't be performed.</p>
<p>(As of this writing, the only <code>Err</code> that might be returned is
<code>Error::LoopBoundExceeded</code>, which is returned if creating the new version
of the <code>BV</code> would exceed <code>max_versions_of_name</code> -- see
<a href="struct.Config.html"><code>Config</code></a>.)</p>
</div><h4 id="method.record_bv_result" class="method"><code>pub fn <a href="#method.record_bv_result" class="fnname">record_bv_result</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;thing: &amp;impl <a class="trait" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/instruction/trait.HasResult.html" title="trait llvm_ir::instruction::HasResult">HasResult</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;resultval: B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#878-897" title="goto source code">[src]</a></h4><div class="docblock"><p>Record the result of <code>thing</code> to be <code>resultval</code>.
Assumes <code>thing</code> is in the current function.
Will fail with <code>Error::LoopBoundExceeded</code> if that would exceed
<code>max_versions_of_name</code> (see <a href="struct.Config.html"><code>Config</code></a>).</p>
</div><h4 id="method.overwrite_latest_version_of_bv" class="method"><code>pub fn <a href="#method.overwrite_latest_version_of_bv" class="fnname">overwrite_latest_version_of_bv</a>(&amp;mut self, name: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a>, bv: B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>)</code><a class="srclink" href="../src/haybale/state.rs.html#909-912" title="goto source code">[src]</a></h4><div class="docblock"><p>Overwrite the latest version of the given <code>Name</code> to instead be <code>bv</code>.
Assumes <code>Name</code> is in the current function.</p>
</div><h4 id="method.type_of" class="method"><code>pub fn <a href="#method.type_of" class="fnname">type_of</a>&lt;T:&nbsp;<a class="trait" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/trait.Typed.html" title="trait llvm_ir::types::Typed">Typed</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(&amp;self, t: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T) -&gt; <a class="struct" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/struct.TypeRef.html" title="struct llvm_ir::types::TypeRef">TypeRef</a></code><a class="srclink" href="../src/haybale/state.rs.html#915-917" title="goto source code">[src]</a></h4><div class="docblock"><p>Convenience function to get the <code>Type</code> of anything that is <code>Typed</code>.</p>
</div><h4 id="method.operand_to_bv" class="method"><code>pub fn <a href="#method.operand_to_bv" class="fnname">operand_to_bv</a>(&amp;self, op: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/operand/enum.Operand.html" title="enum llvm_ir::operand::Operand">Operand</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#922-931" title="goto source code">[src]</a></h4><div class="docblock"><p>Convert an <code>Operand</code> to the appropriate <code>BV</code>.
Assumes the <code>Operand</code> is in the current function.
(All <code>Operand</code>s should be either a constant or a variable we previously added to the state.)</p>
</div><h4 id="method.const_to_bv" class="method"><code>pub fn <a href="#method.const_to_bv" class="fnname">const_to_bv</a>(&amp;self, c: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/constant/enum.Constant.html" title="enum llvm_ir::constant::Constant">Constant</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#934-1238" title="goto source code">[src]</a></h4><div class="docblock"><p>Convert a <code>Constant</code> to the appropriate <code>BV</code>.</p>
</div><h4 id="method.get_pointer_to_function" class="method"><code>pub fn <a href="#method.get_pointer_to_function" class="fnname">get_pointer_to_function</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;funcname: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1479-1483" title="goto source code">[src]</a></h4><div class="docblock"><p>Get a pointer to the given function name. The name must be the
fully-mangled function name, as it appears in the LLVM. The name will be
resolved in the current module; this means that it will first look for a
module-private (e.g., C <code>static</code>) definition in the current module, then
search for a public definition in the same or different module. It will
never return a module-private definition from a different module.</p>
<p>Returns <code>None</code> if no function was found with that name.</p>
</div><h4 id="method.get_pointer_to_function_hook" class="method"><code>pub fn <a href="#method.get_pointer_to_function_hook" class="fnname">get_pointer_to_function_hook</a>(&amp;self, funcname: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1489-1492" title="goto source code">[src]</a></h4><div class="docblock"><p>Get a pointer to the currently active <em>hook</em> for the given function name.</p>
<p>Returns <code>None</code> if no function was found with that name, <em>or</em> if there is no currently
active hook for that function.</p>
</div><h4 id="method.get_func_by_name" class="method"><code>pub fn <a href="#method.get_func_by_name" class="fnname">get_func_by_name</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;funcname: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>&amp;'p <a class="struct" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/function/struct.Function.html" title="struct llvm_ir::function::Function">Function</a>, &amp;'p <a class="struct" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/module/struct.Module.html" title="struct llvm_ir::module::Module">Module</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1504-1518" title="goto source code">[src]</a></h4><div class="docblock"><p>Get a <code>Function</code> by name. The name must be the fully-mangled function
name, as it appears in the LLVM. The name will be resolved in the current
module; this means that it will first look for a module-private (e.g., C
<code>static</code>) definition in the current module, then search for a public
definition in the same or different module. It will never return a
module-private definition from a different module.</p>
<p>Also returns the <code>Module</code> in which the prevailing definition of the <code>Function</code> was found.</p>
<p>Returns <code>None</code> if no function was found with that name.</p>
</div><h4 id="method.read" class="method"><code>pub fn <a href="#method.read" class="fnname">read</a>(&amp;self, addr: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>, bits: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1522-1551" title="goto source code">[src]</a></h4><div class="docblock"><p>Read a value <code>bits</code> bits long from memory at <code>addr</code>.
Note that <code>bits</code> can be arbitrarily large.</p>
</div><h4 id="method.write" class="method"><code>pub fn <a href="#method.write" class="fnname">write</a>(&amp;mut self, addr: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>, val: B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1555-1557" title="goto source code">[src]</a></h4><div class="docblock"><p>Write a value into memory at <code>addr</code>.
Note that <code>val</code> can be an arbitrarily large bitvector.</p>
</div><h4 id="method.size" class="method"><code>pub fn <a href="#method.size" class="fnname">size</a>(&amp;self, ty: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/enum.Type.html" title="enum llvm_ir::types::Type">Type</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a class="srclink" href="../src/haybale/state.rs.html#1623-1627" title="goto source code">[src]</a></h4><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated: <p>Prefer size_in_bits()</p>
</div></div><div class="docblock"><p>Get the size of the <code>Type</code>, in bits.</p>
<p>Accounts for the <code>Project</code>'s pointer size and named struct definitions.</p>
<p>Note that some types have size 0 bits, and this may return <code>0</code>.</p>
<p>Panics if <code>ty</code> is a struct which has no definition in the entire <code>Project</code>,
or if it is a struct/array/vector where one of the elements is a struct with no
definition in the entire <code>Project</code>.</p>
</div><h4 id="method.size_opaque_aware" class="method"><code>pub fn <a href="#method.size_opaque_aware" class="fnname">size_opaque_aware</a>(&amp;self, ty: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/enum.Type.html" title="enum llvm_ir::types::Type">Type</a>, _proj: &amp;'p <a class="struct" href="../haybale/struct.Project.html" title="struct haybale::Project">Project</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1639-1641" title="goto source code">[src]</a></h4><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated: <p>Renamed to size_in_bits()</p>
</div></div><div class="docblock"><p>Get the size of the <code>Type</code>, in bits.</p>
<p>Accounts for the <code>Project</code>'s pointer size and named struct definitions.</p>
<p>Note that some types have size 0 bits, and this may return <code>Some(0)</code>.</p>
<p>Returns <code>None</code> for structs which have no definition in the entire <code>Project</code>,
or for structs/arrays/vectors where one of the elements is a struct with no
definition in the entire <code>Project</code>.</p>
</div><h4 id="method.size_in_bits" class="method"><code>pub fn <a href="#method.size_in_bits" class="fnname">size_in_bits</a>(&amp;self, ty: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/enum.Type.html" title="enum llvm_ir::types::Type">Type</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1652-1654" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the size of the <code>Type</code>, in bits.</p>
<p>Accounts for the <code>Project</code>'s pointer size and named struct definitions.</p>
<p>Note that some types have size 0 bits, and this may return <code>Some(0)</code>.</p>
<p>Returns <code>None</code> for structs which have no definition in the entire <code>Project</code>,
or for structs/arrays/vectors where one of the elements is a struct with no
definition in the entire <code>Project</code>.</p>
</div><h4 id="method.fp_size" class="method"><code>pub fn <a href="#method.fp_size" class="fnname">fp_size</a>(fpt: <a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/enum.FPType.html" title="enum llvm_ir::types::FPType">FPType</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a class="srclink" href="../src/haybale/state.rs.html#1658-1660" title="goto source code">[src]</a></h4><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated: <p>Renamed to fp_size_in_bits</p>
</div></div><div class="docblock"><p>Get the size of the <code>FPType</code>, in bits</p>
</div><h4 id="method.fp_size_in_bits" class="method"><code>pub fn <a href="#method.fp_size_in_bits" class="fnname">fp_size_in_bits</a>(fpt: <a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/enum.FPType.html" title="enum llvm_ir::types::FPType">FPType</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a class="srclink" href="../src/haybale/state.rs.html#1662-1673" title="goto source code">[src]</a></h4><h4 id="method.get_offset_constant_index" class="method"><code>pub fn <a href="#method.get_offset_constant_index" class="fnname">get_offset_constant_index</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;base_type: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/enum.Type.html" title="enum llvm_ir::types::Type">Type</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, <a class="struct" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/struct.TypeRef.html" title="struct llvm_ir::types::TypeRef">TypeRef</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1679-1743" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the offset (in <em>bytes</em>) of the element at the given index, as well as the
<code>Type</code> of the element at that index.</p>
<p>If <code>base_type</code> is a <code>NamedStructType</code>, the struct should be defined in the current module.</p>
</div><h4 id="method.get_offset_bv_index" class="method"><code>pub fn <a href="#method.get_offset_bv_index" class="fnname">get_offset_bv_index</a>&lt;'t, V:&nbsp;<a class="trait" href="../haybale/backend/trait.BV.html" title="trait haybale::backend::BV">BV</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;base_type: &amp;'t <a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/enum.Type.html" title="enum llvm_ir::types::Type">Type</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>V, <br>&nbsp;&nbsp;&nbsp;&nbsp;solver: V::<a class="type" href="../haybale/backend/trait.BV.html#associatedtype.SolverRef" title="type haybale::backend::BV::SolverRef">SolverRef</a><br>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>V, &amp;'t <a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/types/enum.Type.html" title="enum llvm_ir::types::Type">Type</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1753-1778" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the offset (in <em>bytes</em>) of the element at the given index, as well as a
reference to the <code>Type</code> of the element at that index.</p>
<p>This function differs from <code>get_offset_constant_index</code> in that it takes an
arbitrary <code>BV</code> as index instead of a <code>usize</code>, and likewise returns its offset
as a <code>BV</code>.</p>
<p>The result <code>BV</code> will have the same width as the input <code>index</code>.</p>
</div><h4 id="method.add_mem_watchpoint" class="method"><code>pub fn <a href="#method.add_mem_watchpoint" class="fnname">add_mem_watchpoint</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;name: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;watchpoint: <a class="struct" href="../haybale/watchpoints/struct.Watchpoint.html" title="struct haybale::watchpoints::Watchpoint">Watchpoint</a><br>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/haybale/state.rs.html#1789-1791" title="goto source code">[src]</a></h4><div class="docblock"><p>Add a memory watchpoint. It will be enabled unless/until
<code>disable_watchpoint()</code> is called on it.</p>
<p>If a watchpoint with the same name was previously added, this will
replace that watchpoint and return <code>true</code>. Otherwise, this will return
<code>false</code>.</p>
<p>When any watched memory is read or written to, an INFO-level log message
will be generated.</p>
</div><h4 id="method.rm_mem_watchpoint" class="method"><code>pub fn <a href="#method.rm_mem_watchpoint" class="fnname">rm_mem_watchpoint</a>(&amp;mut self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/haybale/state.rs.html#1797-1799" title="goto source code">[src]</a></h4><div class="docblock"><p>Remove the memory watchpoint with the given <code>name</code>.</p>
<p>Returns <code>true</code> if the operation was successful, or <code>false</code> if no
watchpoint with that name was found.</p>
</div><h4 id="method.disable_watchpoint" class="method"><code>pub fn <a href="#method.disable_watchpoint" class="fnname">disable_watchpoint</a>(&amp;mut self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/haybale/state.rs.html#1808-1810" title="goto source code">[src]</a></h4><div class="docblock"><p>Disable the memory watchpoint with the given <code>name</code>. Disabled
watchpoints will not generate any log messages unless/until
<code>enable_watchpoint()</code> is called on them.</p>
<p>Returns <code>true</code> if the operation is successful, or <code>false</code> if no
watchpoint with that name was found. Disabling an already-disabled
watchpoint will have no effect and will return <code>true</code>.</p>
</div><h4 id="method.enable_watchpoint" class="method"><code>pub fn <a href="#method.enable_watchpoint" class="fnname">enable_watchpoint</a>(&amp;mut self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/haybale/state.rs.html#1817-1819" title="goto source code">[src]</a></h4><div class="docblock"><p>Enable the memory watchpoint(s) with the given name.</p>
<p>Returns <code>true</code> if the operation is successful, or <code>false</code> if no
watchpoint with that name was found. Enabling an already-enabled
watchpoint will have no effect and will return <code>true</code>.</p>
</div><h4 id="method.allocate" class="method"><code>pub fn <a href="#method.allocate" class="fnname">allocate</a>(&amp;mut self, bits: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;) -&gt; B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a></code><a class="srclink" href="../src/haybale/state.rs.html#1822-1825" title="goto source code">[src]</a></h4><div class="docblock"><p>Allocate a value of size <code>bits</code>; return a pointer to the newly allocated object</p>
</div><h4 id="method.get_allocation_size" class="method"><code>pub fn <a href="#method.get_allocation_size" class="fnname">get_allocation_size</a>(&amp;mut self, addr: &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1829-1856" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the size, in bits, of the allocation at the given address, or <code>None</code>
if that address is not the result of an <code>alloc()</code>.</p>
</div><h4 id="method.record_path_entry" class="method"><code>pub fn <a href="#method.record_path_entry" class="fnname">record_path_entry</a>(&amp;mut self)</code><a class="srclink" href="../src/haybale/state.rs.html#1859-1863" title="goto source code">[src]</a></h4><div class="docblock"><p>Record the current location as a <code>PathEntry</code> in the current path.</p>
</div><h4 id="method.get_path" class="method"><code>pub fn <a href="#method.get_path" class="fnname">get_path</a>(&amp;self) -&gt; &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../haybale/struct.PathEntry.html" title="struct haybale::PathEntry">PathEntry</a>&lt;'p&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1866-1868" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the <code>PathEntry</code>s that have been recorded, in order</p>
</div><h4 id="method.push_callsite" class="method"><code>pub fn <a href="#method.push_callsite" class="fnname">push_callsite</a>(&amp;mut self, call: &amp;'p <a class="struct" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/instruction/struct.Call.html" title="struct llvm_ir::instruction::Call">Call</a>)</code><a class="srclink" href="../src/haybale/state.rs.html#1871-1873" title="goto source code">[src]</a></h4><div class="docblock"><p>Record entering a normal <code>Call</code> at the current location</p>
</div><h4 id="method.push_invokesite" class="method"><code>pub fn <a href="#method.push_invokesite" class="fnname">push_invokesite</a>(&amp;mut self, invoke: &amp;'p <a class="struct" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/terminator/struct.Invoke.html" title="struct llvm_ir::terminator::Invoke">Invoke</a>)</code><a class="srclink" href="../src/haybale/state.rs.html#1876-1878" title="goto source code">[src]</a></h4><div class="docblock"><p>Record entering the given <code>Invoke</code> at the current location</p>
</div><h4 id="method.pop_callsite" class="method"><code>pub fn <a href="#method.pop_callsite" class="fnname">pop_callsite</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Callsite&lt;'p&gt;&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1905-1916" title="goto source code">[src]</a></h4><div class="docblock"><p>Record leaving the current function. Returns the <code>Callsite</code> at which the
current function was called, or <code>None</code> if the current function was the
top-level function.</p>
<p>Also restores the caller's local variables.</p>
</div><h4 id="method.current_callstack_depth" class="method"><code>pub fn <a href="#method.current_callstack_depth" class="fnname">current_callstack_depth</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../src/haybale/state.rs.html#1921-1923" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the current callstack depth. <code>0</code> indicates we're in the toplevel
function, <code>1</code> indicates we're in a function directly called by the
toplevel function, etc.</p>
</div><h4 id="method.save_backtracking_point" class="method"><code>pub fn <a href="#method.save_backtracking_point" class="fnname">save_backtracking_point</a>(&amp;mut self, bb_to_enter: &amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a>, constraint: B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>)</code><a class="srclink" href="../src/haybale/state.rs.html#1928-1951" title="goto source code">[src]</a></h4><div class="docblock"><p>Save the current state, about to enter the <code>BasicBlock</code> with the given <code>Name</code> (which must be
in the same <code>Module</code> and <code>Function</code> as <code>state.cur_loc</code>), as a backtracking point.
The constraint will be added only if we end up backtracking to this point, and only then.</p>
</div><h4 id="method.revert_to_backtracking_point" class="method"><code>pub fn <a href="#method.revert_to_backtracking_point" class="fnname">revert_to_backtracking_point</a>(&amp;mut self) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#1976-1990" title="goto source code">[src]</a></h4><div class="docblock"><p>returns <code>Ok(true)</code> if the operation was successful, <code>Ok(false)</code> if there are
no saved backtracking points, or <code>Err</code> for other errors</p>
</div><h4 id="method.count_backtracking_points" class="method"><code>pub fn <a href="#method.count_backtracking_points" class="fnname">count_backtracking_points</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../src/haybale/state.rs.html#1993-1995" title="goto source code">[src]</a></h4><div class="docblock"><p>returns the number of saved backtracking points</p>
</div><h4 id="method.pretty_backtrace" class="method"><code>pub fn <a href="#method.pretty_backtrace" class="fnname">pretty_backtrace</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class="srclink" href="../src/haybale/state.rs.html#2000-2032" title="goto source code">[src]</a></h4><div class="docblock"><p>returns a <code>String</code> containing a formatted view of the current backtrace
(in terms of LLVM locations, and possibly also source locations depending
on the <code>Config</code>)</p>
</div><h4 id="method.pretty_path_llvm" class="method"><code>pub fn <a href="#method.pretty_path_llvm" class="fnname">pretty_path_llvm</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class="srclink" href="../src/haybale/state.rs.html#2036-2049" title="goto source code">[src]</a></h4><div class="docblock"><p>returns a <code>String</code> containing a formatted view of the full path which led
to this point, in terms of LLVM locations</p>
</div><h4 id="method.pretty_path_llvm_instructions" class="method"><code>pub fn <a href="#method.pretty_path_llvm_instructions" class="fnname">pretty_path_llvm_instructions</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class="srclink" href="../src/haybale/state.rs.html#2055-2107" title="goto source code">[src]</a></h4><div class="docblock"><p>returns a <code>String</code> containing a formatted view of the full path which led
to this point, in terms of LLVM IR instructions. If the Path includes any
hooked functions, the instructions which might be contained within those
functions are not included.</p>
</div><h4 id="method.pretty_path_source" class="method"><code>pub fn <a href="#method.pretty_path_source" class="fnname">pretty_path_source</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class="srclink" href="../src/haybale/state.rs.html#2112-2138" title="goto source code">[src]</a></h4><div class="docblock"><p>returns a <code>String</code> containing a formatted view of the full path which led
to this point, in terms of source locations</p>
</div><h4 id="method.pretty_path_interleaved" class="method"><code>pub fn <a href="#method.pretty_path_interleaved" class="fnname">pretty_path_interleaved</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class="srclink" href="../src/haybale/state.rs.html#2143-2167" title="goto source code">[src]</a></h4><div class="docblock"><p>returns a <code>String</code> containing a formatted view of the full path which led
to this point, in terms of both LLVM and source locations (interleaved
appropriately)</p>
</div><h4 id="method.get_path_length" class="method"><code>pub fn <a href="#method.get_path_length" class="fnname">get_path_length</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../src/haybale/state.rs.html#2173-2175" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the number of LLVM instructions in the current path.
The returned value is only accurate if the path under
analysis does not include a panic, exception, exit,
or any hooked calls (such as inline assembly).</p>
</div><h4 id="method.demangle" class="method"><code>pub fn <a href="#method.demangle" class="fnname">demangle</a>(&amp;self, funcname: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class="srclink" href="../src/haybale/state.rs.html#2182-2187" title="goto source code">[src]</a></h4><div class="docblock"><p>Attempt to demangle the given <code>funcname</code> as appropriate based on the
<code>Config</code>.</p>
<p>If this fails to demangle <code>funcname</code>, it just returns a copy of
<code>funcname</code> unchanged.</p>
</div><h4 id="method.all_vars_in_cur_fn" class="method"><code>pub fn <a href="#method.all_vars_in_cur_fn" class="fnname">all_vars_in_cur_fn</a>(&amp;self) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>&amp;<a class="enum" href="https://docs.rs/llvm-ir/0.8.0/llvm_ir/name/enum.Name.html" title="enum llvm_ir::name::Name">Name</a>, &amp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#2199-2201" title="goto source code">[src]</a></h4><div class="docblock"><p>Get the most recent <code>BV</code> created for each <code>Name</code> in the current function.
Returns pairs of the <code>Name</code> and the <code>BV</code> assigned to that <code>Name</code>.</p>
<p>Returned pairs will be sorted by <code>Name</code>.</p>
</div><h4 id="method.current_assignments_as_pretty_string" class="method"><code>pub fn <a href="#method.current_assignments_as_pretty_string" class="fnname">current_assignments_as_pretty_string</a>(&amp;self) -&gt; <a class="type" href="../haybale/type.Result.html" title="type haybale::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#2204-2216" title="goto source code">[src]</a></h4><div class="docblock"><p>returns a <code>String</code> describing a set of satisfying assignments for all variables</p>
</div><h4 id="method.full_error_message_with_context" class="method"><code>pub fn <a href="#method.full_error_message_with_context" class="fnname">full_error_message_with_context</a>(&amp;self, e: <a class="enum" href="../haybale/enum.Error.html" title="enum haybale::Error">Error</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class="srclink" href="../src/haybale/state.rs.html#2223-2271" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a <code>String</code> describing both the error and the context in which it
occurred (backtrace, full path to error, variable values at the point of
error, etc). Exactly which information is included is partially dependent
on the environment variables <code>HAYBALE_DUMP_PATH</code> and <code>HAYBALE_DUMP_VARS</code>,
as explained in the message.</p>
</div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><h3 id="impl-Clone" class="impl"><code class="in-band">impl&lt;'p, B:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="../haybale/backend/trait.Backend.html" title="trait haybale::backend::Backend">Backend</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../haybale/struct.State.html" title="struct haybale::State">State</a>&lt;'p, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.SolverRef" title="type haybale::backend::Backend::SolverRef">SolverRef</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.Memory" title="type haybale::backend::Backend::Memory">Memory</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../src/haybale/state.rs.html#36" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.clone" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="../haybale/struct.State.html" title="struct haybale::State">State</a>&lt;'p, B&gt;</code><a class="srclink" href="../src/haybale/state.rs.html#36" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id="method.clone_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#128" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl&lt;'p, B&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../haybale/struct.State.html" title="struct haybale::State">State</a>&lt;'p, B&gt;</code><a href="#impl-RefUnwindSafe" class="anchor"></a><a class="srclink" href="../src/haybale/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Send" class="impl"><code class="in-band">impl&lt;'p, B&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../haybale/struct.State.html" title="struct haybale::State">State</a>&lt;'p, B&gt;</code><a href="#impl-Send" class="anchor"></a><a class="srclink" href="../src/haybale/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Sync" class="impl"><code class="in-band">impl&lt;'p, B&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../haybale/struct.State.html" title="struct haybale::State">State</a>&lt;'p, B&gt;</code><a href="#impl-Sync" class="anchor"></a><a class="srclink" href="../src/haybale/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Unpin" class="impl"><code class="in-band">impl&lt;'p, B&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../haybale/struct.State.html" title="struct haybale::State">State</a>&lt;'p, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;B as <a class="trait" href="../haybale/backend/trait.Backend.html" title="trait haybale::backend::Backend">Backend</a>&gt;::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.BV" title="type haybale::backend::Backend::BV">BV</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;B as <a class="trait" href="../haybale/backend/trait.Backend.html" title="trait haybale::backend::Backend">Backend</a>&gt;::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.Memory" title="type haybale::backend::Backend::Memory">Memory</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;B as <a class="trait" href="../haybale/backend/trait.Backend.html" title="trait haybale::backend::Backend">Backend</a>&gt;::<a class="type" href="../haybale/backend/trait.Backend.html#associatedtype.SolverRef" title="type haybale::backend::Backend::SolverRef">SolverRef</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code><a href="#impl-Unpin" class="anchor"></a><a class="srclink" href="../src/haybale/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl&lt;'p, B&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../haybale/struct.State.html" title="struct haybale::State">State</a>&lt;'p, B&gt;</code><a href="#impl-UnwindSafe" class="anchor"></a><a class="srclink" href="../src/haybale/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.type_id" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#207-211" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214-218" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#215" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545-549" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#546" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#534-541" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#538" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-ToOwned" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href="#impl-ToOwned" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#80-92" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Owned" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id="method.to_owned" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#85" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id="method.clone_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></h4><div class="item-info hidden"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#582-591" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#588" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#568-577" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#574" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="haybale"></div>
    <script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>