var searchIndex = JSON.parse('{\
"haybale":{"doc":"For an introduction to the crate and how to get started,…","i":[[3,"Project","haybale","A `Project` is a collection of LLVM code to be explored,…",null,null],[3,"Location","","Fully describes a code location within the LLVM IR.",null,null],[12,"module","","",0,null],[12,"func","","",0,null],[12,"bb","","",0,null],[12,"instr","","",0,null],[12,"source_loc","","Source location which this IR location corresponds to, if…",0,null],[3,"LocationDescription","","Describes a location in LLVM IR in a format more suitable…",null,null],[12,"modname","","",1,null],[12,"funcname","","",1,null],[12,"bbname","","",1,null],[12,"instr","","",1,null],[12,"source_loc","","",1,null],[3,"PathEntry","","Describes one segment of a path through the LLVM IR. The…",null,null],[12,"0","","",2,null],[3,"State","","A `State` describes the full program state at a given…",null,null],[12,"solver","","Reference to the solver instance being used",3,null],[12,"config","","The configuration being used",3,null],[12,"cur_loc","","Indicates the instruction which is currently being executed",3,null],[3,"ExecutionManager","","An `ExecutionManager` allows you to symbolically explore…",null,null],[4,"BBInstrIndex","","Denotes either a particular instruction in a basic block,…",null,null],[13,"Instr","","Index of the instruction within the basic block.…",4,null],[13,"Terminator","","Indicates the basic block terminator (not one of its…",4,null],[4,"Error","","Error types used throughout this crate.",null,null],[13,"Unsat","","While performing an operation, we discovered the current…",5,null],[13,"LoopBoundExceeded","","The current path has exceeded the configured `loop_bound`…",5,null],[13,"NullPointerDereference","","The current path has attempted to dereference a null…",5,null],[13,"FunctionNotFound","","Processing a call of a function with the given name, but…",5,null],[13,"SolverError","","The solver returned this processing error while evaluating…",5,null],[13,"UnsupportedInstruction","","Encountered an LLVM instruction which is not currently…",5,null],[13,"MalformedInstruction","","Encountered an LLVM instruction which was malformed, or at…",5,null],[13,"UnreachableInstruction","","Reached an LLVM `Unreachable` instruction",5,null],[13,"FailedToResolveFunctionPointer","","Failed to interpret some symbolic value (`BV`) as a…",5,null],[13,"HookReturnValueMismatch","","The hook for some function returned a value which didn\'t…",5,null],[13,"OtherError","","Some kind of error which doesn\'t fall into one of the…",5,null],[4,"ReturnValue","","A simple enum describing the value returned from a function",null,null],[13,"Return","","The function or call returns this value",6,null],[13,"ReturnVoid","","The function or call returns void",6,null],[13,"Throw","","The function or call throws this value (using the LLVM…",6,null],[13,"Abort","","The function or call aborts without ever returning (e.g.,…",6,null],[4,"SolutionValue","","A simple enum describing either an integer value or a…",null,null],[13,"I8","","",7,null],[13,"I16","","",7,null],[13,"I32","","",7,null],[13,"I64","","",7,null],[13,"Ptr","","",7,null],[5,"symex_function","","Begin symbolic execution of the function named `funcname`,…",null,[[["project",3],["config",3],["backend",8]],[["executionmanager",3],["backend",8]]]],[5,"find_zero_of_func","","Given a function, find values of its inputs such that it…",null,[[["project",3],["config",3],["defaultbackend",3]],[["option",4],["result",4],["string",3]]]],[5,"get_possible_return_values_of_func","","Get a description of the possible return values of a…",null,[[["config",3],["project",3],["option",4],["defaultbackend",3]],[["possiblesolutions",4],["returnvalue",4]]]],[11,"from_bc_path","","Construct a new `Project` from a path to an LLVM bitcode…",8,[[],[["result",4],["string",3]]]],[11,"from_bc_paths","","Construct a new `Project` from multiple LLVM bitcode files",8,[[],[["result",4],["string",3]]]],[11,"from_bc_dir","","Construct a new `Project` from a path to a directory…",8,[[],[["result",4],["error",3]]]],[11,"from_bc_dir_with_blacklist","","Construct a new `Project` from a path to a directory…",8,[[],[["result",4],["error",3]]]],[11,"add_bc_path","","Add the code in the given LLVM bitcode file to the `Project`",8,[[],[["result",4],["string",3]]]],[11,"add_bc_dir","","Add the code in the given directory to the `Project`. See…",8,[[],[["result",4],["error",3]]]],[11,"add_bc_dir_with_blacklist","","Add the code in the given directory, except for…",8,[[],[["result",4],["error",3]]]],[11,"pointer_size_bits","","Get the pointer size used by the `Project`, in bits. E.g.,…",8,[[]]],[11,"all_functions","","Iterate over all `Function`s in the `Project`. Gives pairs…",8,[[]]],[11,"all_global_vars","","Iterate over all `GlobalVariable`s in the `Project`. Gives…",8,[[]]],[11,"all_global_aliases","","Iterate over all `GlobalAlias`es in the `Project`. Gives…",8,[[]]],[11,"all_named_struct_types","","Iterate over all named struct types in the `Project`.…",8,[[]]],[11,"active_module_names","","Get the names of the LLVM modules which have been parsed…",8,[[]]],[11,"get_func_by_name","","Search the project for a function with the given name. If…",8,[[],["option",4]]],[11,"get_named_struct_def","","Get the definition of the named struct with the given…",8,[[],["result",6]]],[11,"state","","Provides access to the `State` resulting from the end of…",9,[[],["state",3]]],[11,"mut_state","","Provides mutable access to the underlying `State` (see…",9,[[],["state",3]]],[11,"param_bvs","","Provides access to the `BV` objects representing each of…",9,[[],["vec",3]]],[0,"config","","The `Config` structure for configuring `haybale`, and…",null,null],[3,"Config","haybale::config","Various settings which affect how the symbolic execution…",null,null],[12,"loop_bound","","Maximum number of times to execute any given line of LLVM…",10,null],[12,"max_callstack_depth","","Maximum callstack depth to allow when symbolically…",10,null],[12,"solver_query_timeout","","Maximum amount of time to allow for any single solver query.",10,null],[12,"null_pointer_checking","","Should we check each memory access for possible `NULL`…",10,null],[12,"concretize_memcpy_lengths","","When encountering a `memcpy`, `memset`, or `memmove` with…",10,null],[12,"max_memcpy_length","","Maximum supported length of a `memcpy`, `memset`, or…",10,null],[12,"squash_unsats","","`Error::Unsat` is an error type which is used internally,…",10,null],[12,"trust_llvm_assumes","","When encountering the `llvm.assume()` intrinsic, should we…",10,null],[12,"function_hooks","","The set of currently active function hooks; see…",10,null],[12,"callbacks","","The set of currently active callbacks; see `Callbacks` for…",10,null],[12,"initial_mem_watchpoints","","The initial memory watchpoints when a `State` is created…",10,null],[12,"demangling","","Controls the (attempted) demangling of function names in…",10,null],[12,"print_source_info","","If `true`, then `haybale` will attempt to print source…",10,null],[12,"print_module_name","","If `true`, then `haybale` will include the module name…",10,null],[4,"Demangling","","Enum used for the `demangling` option in `Config`.",null,null],[13,"NoDemangling","","Don\'t try to demangle",11,null],[13,"CPP","","Try to demangle using the C++ demangler (suitable for…",11,null],[13,"Rust","","Try to demangle using the Rust demangler (suitable for…",11,null],[4,"NullPointerChecking","","Enum used for the `null_pointer_checking` option in…",null,null],[13,"Simple","","All memory accesses will be checked to ensure their…",12,null],[13,"SplitPath","","All memory accesses will be checked to ensure their…",12,null],[13,"None","","Memory accesses will not be checked for `NULL` addresses.…",12,null],[4,"Concretize","","Enum used for the `concretize_memcpy_lengths` option in…",null,null],[13,"Symbolic","","Handle everything fully symbolically - that is, have the…",13,null],[13,"Arbitrary","","Pick one possible value arbitrarily. Often this may choose…",13,null],[13,"Prefer","","Prefer the given `u64` value if it is a possible value.…",13,null],[13,"Maximum","","Choose the maximum possible value. `Maximum` will be…",13,null],[13,"Minimum","","Choose the minimum possible value. `Minimum` will be…",13,null],[11,"new","","Creates a new `Config` with defaults for all the options,…",10,[[]]],[0,"alloc_utils","haybale","Utility functions for performing memory allocation. These…",null,null],[5,"malloc","haybale::alloc_utils","Allocate a number of bytes given by the `Operand`.",null,[[["operand",4],["state",3]],["result",6]]],[5,"zalloc","","Allocate a number of bytes given by the `Operand`. The…",null,[[["operand",4],["state",3]],["result",6]]],[5,"calloc","","Allocate a number of bytes given by `a` times `b`, where…",null,[[["operand",4],["state",3]],["result",6]]],[5,"realloc","","Reallocate the given `addr` to be at least the number of…",null,[[["operand",4],["state",3]],["result",6]]],[0,"backend","haybale","Traits which abstract over the backend (BV types, memory…",null,null],[3,"CellMemoryBackend","haybale::backend","",null,null],[3,"DefaultBackend","","",null,null],[8,"Backend","","A `Backend` is just a collection of types which together…",null,null],[16,"SolverRef","","",14,null],[16,"BV","","",14,null],[16,"Memory","","",14,null],[8,"SolverRef","","Trait for something which acts as a reference to a…",null,null],[16,"BV","","",15,null],[16,"Array","","",15,null],[10,"new","","Create a new `Btor` instance, initialize it as necessary,…",15,[[]]],[10,"duplicate","","As opposed to `clone()` which merely clones the reference,…",15,[[]]],[10,"match_bv","","Given a `BV` originally created for any `SolverRef`, get…",15,[[],["option",4]]],[10,"match_array","","Given an `Array` originally created for any `SolverRef`,…",15,[[],["option",4]]],[8,"BV","","Trait for things which can act like bitvectors.",null,null],[16,"SolverRef","","",16,null],[10,"new","","",16,[[["option",4]]]],[10,"from_bool","","",16,[[]]],[10,"from_i32","","",16,[[]]],[10,"from_u32","","",16,[[]]],[10,"from_i64","","",16,[[]]],[10,"from_u64","","",16,[[]]],[10,"zero","","",16,[[]]],[10,"one","","",16,[[]]],[10,"ones","","",16,[[]]],[10,"from_binary_str","","",16,[[]]],[10,"from_dec_str","","",16,[[]]],[10,"from_hex_str","","",16,[[]]],[10,"as_binary_str","","",16,[[],[["string",3],["option",4]]]],[10,"as_u64","","",16,[[],["option",4]]],[10,"as_bool","","",16,[[],["option",4]]],[10,"get_a_solution","","",16,[[],[["result",6],["bvsolution",3]]]],[10,"get_solver","","",16,[[]]],[10,"get_id","","",16,[[]]],[10,"get_width","","",16,[[]]],[10,"get_symbol","","",16,[[],["option",4]]],[10,"set_symbol","","",16,[[["option",4]]]],[10,"is_const","","",16,[[]]],[10,"has_same_width","","",16,[[]]],[10,"assert","","",16,[[],["result",6]]],[10,"is_failed_assumption","","",16,[[]]],[10,"_eq","","",16,[[]]],[10,"_ne","","",16,[[]]],[10,"add","","",16,[[]]],[10,"sub","","",16,[[]]],[10,"mul","","",16,[[]]],[10,"udiv","","",16,[[]]],[10,"sdiv","","",16,[[]]],[10,"urem","","",16,[[]]],[10,"srem","","",16,[[]]],[10,"smod","","",16,[[]]],[10,"inc","","",16,[[]]],[10,"dec","","",16,[[]]],[10,"neg","","",16,[[]]],[10,"uaddo","","",16,[[]]],[10,"saddo","","",16,[[]]],[10,"usubo","","",16,[[]]],[10,"ssubo","","",16,[[]]],[10,"umulo","","",16,[[]]],[10,"smulo","","",16,[[]]],[10,"sdivo","","",16,[[]]],[10,"not","","",16,[[]]],[10,"and","","",16,[[]]],[10,"or","","",16,[[]]],[10,"xor","","",16,[[]]],[10,"nand","","",16,[[]]],[10,"nor","","",16,[[]]],[10,"xnor","","",16,[[]]],[10,"sll","","",16,[[]]],[10,"srl","","",16,[[]]],[10,"sra","","",16,[[]]],[10,"rol","","",16,[[]]],[10,"ror","","",16,[[]]],[10,"redand","","",16,[[]]],[10,"redor","","",16,[[]]],[10,"redxor","","",16,[[]]],[10,"ugt","","",16,[[]]],[10,"ugte","","",16,[[]]],[10,"sgt","","",16,[[]]],[10,"sgte","","",16,[[]]],[10,"ult","","",16,[[]]],[10,"ulte","","",16,[[]]],[10,"slt","","",16,[[]]],[10,"slte","","",16,[[]]],[10,"zext","","",16,[[]]],[10,"sext","","",16,[[]]],[10,"slice","","",16,[[]]],[10,"concat","","",16,[[]]],[10,"repeat","","",16,[[]]],[10,"iff","","",16,[[]]],[10,"implies","","",16,[[]]],[10,"cond_bv","","",16,[[]]],[11,"zero_extend_to_bits","","Zero-extend a `BV` to the specified number of bits. The…",16,[[]]],[11,"sign_extend_to_bits","","Sign-extend a `BV` to the specified number of bits. The…",16,[[]]],[11,"uadds","","Saturating addition, unsigned. The result will be the same…",16,[[]]],[11,"sadds","","Saturating addition, signed. The result will be the same…",16,[[]]],[11,"usubs","","Saturating subtraction, unsigned. The result will be the…",16,[[]]],[11,"ssubs","","Saturating subtraction, signed. The result will be the…",16,[[]]],[8,"Memory","","Trait for things which can act like \'memories\', that is,…",null,null],[16,"SolverRef","","",17,null],[16,"Index","","",17,null],[16,"Value","","",17,null],[10,"new_uninitialized","","A new `Memory`, whose contents at all addresses are…",17,[[["option",4]]]],[10,"new_zero_initialized","","A new `Memory`, whose contents at all addresses are…",17,[[["option",4]]]],[10,"read","","Read any number (>0) of bits of memory, at any alignment.…",17,[[],["result",6]]],[10,"write","","Write any number (>0) of bits of memory, at any alignment.",17,[[],["result",6]]],[10,"get_solver","","Get a reference to the solver instance this `Memory`…",17,[[]]],[10,"change_solver","","Adapt the `Memory` to a new solver instance.",17,[[]]],[0,"callbacks","haybale","Functions and structures for defining and activating…",null,null],[3,"Callbacks","haybale::callbacks","",null,null],[11,"add_instruction_callback","","Add an instruction callback. `haybale` will call the…",18,[[]]],[11,"add_terminator_callback","","Add a terminator callback. `haybale` will call the…",18,[[]]],[0,"cell_memory","haybale","Implementation of a `Memory` based on a Boolector array…",null,null],[3,"Memory","haybale::cell_memory","",null,null],[18,"INDEX_BITS","","",19,null],[18,"CELL_BITS","","",19,null],[18,"BITS_IN_BYTE","","",19,null],[18,"LOG_BITS_IN_BYTE","","",19,null],[18,"CELL_BYTES","","",19,null],[18,"LOG_CELL_BYTES","","",19,null],[18,"CELL_OFFSET_MASK","","",19,null],[11,"new_uninitialized","","A new `Memory`, whose contents at all addresses are…",19,[[["option",4],["rc",3],["btor",3]]]],[11,"new_zero_initialized","","A new `Memory`, whose contents at all addresses are…",19,[[["option",4],["rc",3],["btor",3]]]],[11,"get_solver","","Get a reference to the `Btor` instance this `Memory`…",19,[[],[["rc",3],["btor",3]]]],[11,"change_solver","","Adapt the `Memory` to a new `Btor` instance.",19,[[["rc",3],["btor",3]]]],[11,"read","","Read any number (>0) of bits of memory, at any alignment.…",19,[[["bv",3]],[["result",6],["bv",3]]]],[11,"write","","Write any number (>0) of bits of memory, at any alignment.",19,[[["bv",3],["bv",3],["rc",3]],["result",6]]],[11,"maybe_demangle","haybale::config","Attempts to demangle the given function name, as…",11,[[],["string",3]]],[11,"autodetect","","Guesses an appropriate `Demangling` for the given `Project`.",11,[[["project",3]]]],[0,"function_hooks","haybale","Functions and structures for defining and activating…",null,null],[3,"FunctionHooks","haybale::function_hooks","A set of function hooks, which will be executed instead of…",null,null],[5,"generic_stub_hook","","This hook ignores the function arguments and returns an…",null,[[["iscall",8],["project",3],["state",3]],[["result",6],["returnvalue",4]]]],[5,"abort_hook","","This hook ignores the function arguments and returns…",null,[[["iscall",8],["project",3],["state",3]],[["result",6],["returnvalue",4]]]],[6,"Argument","","An `Argument` represents a single argument to a called…",null,null],[8,"IsCall","","`IsCall` exists to unify the commonalities between LLVM…",null,null],[10,"get_called_func","","",20,[[],["either",4]]],[10,"get_arguments","","",20,[[],["vec",3]]],[10,"get_return_attrs","","",20,[[],["vec",3]]],[10,"get_fn_attrs","","",20,[[],["vec",3]]],[10,"get_calling_convention","","",20,[[],["callingconvention",4]]],[11,"new","","Create a blank `FunctionHooks` instance with no function…",21,[[]]],[11,"add","","Adds a function hook. The `hook` will be executed instead…",21,[[]]],[11,"add_cpp_demangled","","Exactly like `add()`, but takes the (C++) demangled name…",21,[[]]],[11,"add_rust_demangled","","Exactly like `add()`, but takes the (Rust) demangled name…",21,[[]]],[11,"add_inline_asm_hook","","Add a hook to be used for calls to inline assembly. This…",21,[[]]],[11,"add_default_hook","","Add a hook to be used if no other definition or hook is…",21,[[]]],[11,"remove","","Removes the function hook for the given function, which…",21,[[]]],[11,"remove_cpp_demangled","","Removes the function hook for the given function, which…",21,[[]]],[11,"remove_rust_demangled","","Removes the function hook for the given function, which…",21,[[]]],[11,"remove_inline_asm_hook","","Removes the function hook used for calls to inline…",21,[[]]],[11,"remove_default_hook","","Removes the default function hook which was added with…",21,[[]]],[11,"is_hooked","","Determine whether there is an active hook for the given…",21,[[]]],[11,"has_inline_asm_hook","","Is there currently an inline asm hook active? (See…",21,[[]]],[11,"has_default_hook","","Is there currently a default hook active? (See…",21,[[]]],[0,"hook_utils","haybale","Utility functions for performing memset or memcpy…",null,null],[5,"memset","haybale::hook_utils","Set `num_bytes` bytes of memory at address `addr` each to…",null,[[["operand",4],["state",3]],["result",6]]],[5,"memset_bv","","Just like `memset()` above, but takes `BV`s instead of…",null,[[["state",3]],["result",6]]],[5,"memcpy","","Copies `num_bytes` bytes of memory from address `src` to…",null,[[["operand",4],["state",3]],["result",6]]],[5,"memcpy_bv","","Just like `memcpy()` above, but takes `BV`s instead of…",null,[[["state",3]],["result",6]]],[0,"simple_memory","haybale","Simple implementation of a `Memory` based on a Boolector…",null,null],[3,"Memory","haybale::simple_memory","",null,null],[18,"CELL_BITS","","",22,null],[18,"BITS_IN_BYTE","","",22,null],[18,"LOG_BITS_IN_BYTE","","",22,null],[18,"CELL_BYTES","","",22,null],[11,"new_uninitialized","","A new `Memory`, whose contents at all addresses are…",22,[[["option",4],["rc",3],["btor",3]]]],[11,"new_zero_initialized","","A new `Memory`, whose contents at all addresses are…",22,[[["option",4],["rc",3],["btor",3]]]],[11,"get_solver","","Get a reference to the `Btor` instance this `Memory`…",22,[[],[["rc",3],["btor",3]]]],[11,"change_solver","","Adapt the `Memory` to a new `Btor` instance.",22,[[["rc",3],["btor",3]]]],[11,"read","","Read any number (>0) of bits of memory, at any alignment.…",22,[[["bv",3]],[["result",6],["bv",3]]]],[11,"write","","Write any number (>0) of bits of memory, at any alignment.",22,[[["bv",3],["bv",3],["rc",3]],["result",6]]],[0,"solver_utils","haybale","Simple utilities for interacting with the solver",null,null],[4,"PossibleSolutions","haybale::solver_utils","",null,null],[13,"Exactly","","This is exactly the set of possible solutions; there are…",23,null],[13,"AtLeast","","All of the solutions in this set are possible solutions,…",23,null],[4,"SolutionCount","","",null,null],[13,"Exactly","","There are exactly this many solutions",24,null],[13,"AtLeast","","There are at least this many solutions",24,null],[5,"sat","","Returns `true` if current constraints are satisfiable,…",null,[[["btor",3]],["result",6]]],[5,"sat_with_extra_constraints","","Returns `true` if the current constraints plus the…",null,[[["btor",3]],["result",6]]],[5,"bvs_must_be_equal","","Returns `true` if under the current constraints, `a` and…",null,[[["btor",3]],["result",6]]],[5,"bvs_can_be_equal","","Returns `true` if under the current constraints, `a` and…",null,[[["btor",3]],["result",6]]],[5,"get_possible_solutions_for_bv","","Get a description of the possible solutions for the `BV`.",null,[[],[["possiblesolutions",4],["result",6]]]],[5,"max_possible_solution_for_bv_as_u64","","Get the maximum possible solution for the `BV`: that is,…",null,[[],[["result",6],["option",4]]]],[5,"min_possible_solution_for_bv_as_u64","","Get the minimum possible solution for the `BV`: that is,…",null,[[],[["result",6],["option",4]]]],[5,"max_possible_solution_for_bv_as_binary_str","","Get the maximum possible solution for the `BV`: that is,…",null,[[],[["option",4],["result",6]]]],[5,"min_possible_solution_for_bv_as_binary_str","","Get the minimum possible solution for the `BV`: that is,…",null,[[],[["option",4],["result",6]]]],[11,"empty","","Create a new, empty, `PossibleSolutions` (representing no…",23,[[]]],[11,"exactly_one","","Create a new `PossibleSolutions` representing exactly one…",23,[[]]],[11,"exactly_two","","Create a new `PossibleSolutions` repesenting exactly two…",23,[[]]],[11,"as_u64_solutions","","Convert a `PossibleSolutions` over `BVSolution` into a…",23,[[],[["option",4],["possiblesolutions",4]]]],[11,"count","","Get a count of how many possible solutions there are.",23,[[],["solutioncount",4]]],[11,"to_string_with_module","haybale","Format this `Location` as a string, including the full…",0,[[],["string",3]]],[11,"to_string_no_module","","Format this `Location` as a string, omitting the module name",0,[[],["string",3]]],[11,"to_string_short_module","","Format this `Location` as a string, including the short…",0,[[],["string",3]]],[11,"new","","`start_loc`: the `Location` where the `State` should begin…",3,[[["project",3],["location",3],["config",3]]]],[11,"fork","","Fully duplicate the `State`. Unlike with `clone()`, the…",3,[[]]],[11,"sat","","Returns `true` if current constraints are satisfiable,…",3,[[],["result",6]]],[11,"sat_with_extra_constraints","","Returns `true` if the current constraints plus the given…",3,[[],["result",6]]],[11,"bvs_must_be_equal","","Returns `true` if under the current constraints, `a` and…",3,[[],["result",6]]],[11,"bvs_can_be_equal","","Returns `true` if under the current constraints, `a` and…",3,[[],["result",6]]],[11,"get_a_solution_for_bv","","Get one possible concrete value for the `BV`. Returns…",3,[[],[["option",4],["result",6]]]],[11,"get_a_solution_for_irname","","Get one possible concrete value for the given IR `Name`…",3,[[["string",3],["name",4]],[["option",4],["result",6]]]],[11,"get_possible_solutions_for_bv","","Get a description of the possible solutions for the `BV`.",3,[[],[["possiblesolutions",4],["result",6]]]],[11,"get_possible_solutions_for_irname","","Get a description of the possible solutions for the given…",3,[[["string",3],["name",4]],[["possiblesolutions",4],["result",6]]]],[11,"max_possible_solution_for_bv_as_u64","","Get the maximum possible solution for the `BV`: that is,…",3,[[],[["result",6],["option",4]]]],[11,"max_possible_solution_for_irname_as_u64","","Get the maximum possible solution for the given IR `Name`…",3,[[["string",3],["name",4]],[["result",6],["option",4]]]],[11,"min_possible_solution_for_bv_as_u64","","Get the minimum possible solution for the `BV`: that is,…",3,[[],[["result",6],["option",4]]]],[11,"min_possible_solution_for_irname_as_u64","","Get the minimum possible solution for the given IR `Name`…",3,[[["string",3],["name",4]],[["result",6],["option",4]]]],[11,"bv_from_bool","","Create a `BV` constant representing the given `bool`…",3,[[]]],[11,"bv_from_i32","","Create a `BV` representing the given constant `i32` value,…",3,[[]]],[11,"bv_from_u32","","Create a `BV` representing the given constant `u32` value,…",3,[[]]],[11,"bv_from_i64","","Create a `BV` representing the given constant `i64` value,…",3,[[]]],[11,"bv_from_u64","","Create a `BV` representing the given constant `u64` value,…",3,[[]]],[11,"zero","","Create a `BV` representing the constant `0` of the given…",3,[[]]],[11,"one","","Create a `BV` representing the constant `1` of the given…",3,[[]]],[11,"ones","","Create a `BV` constant of the given width, where all bits…",3,[[]]],[11,"new_bv_with_name","","Create a new (unconstrained) `BV` for the given `Name` (in…",3,[[["name",4]],["result",6]]],[11,"assign_bv_to_name","","Assign the given `BV` to the given `Name` (in the current…",3,[[["name",4]],["result",6]]],[11,"record_bv_result","","Record the result of `thing` to be `resultval`. Assumes…",3,[[],["result",6]]],[11,"overwrite_latest_version_of_bv","","Overwrite the latest version of the given `Name` to…",3,[[["name",4]]]],[11,"type_of","","Convenience function to get the `Type` of anything that is…",3,[[],["typeref",3]]],[11,"operand_to_bv","","Convert an `Operand` to the appropriate `BV`. Assumes the…",3,[[["operand",4]],["result",6]]],[11,"const_to_bv","","Convert a `Constant` to the appropriate `BV`.",3,[[["constant",4]],["result",6]]],[11,"get_pointer_to_function","","Get a pointer to the given function name. The name must be…",3,[[],["option",4]]],[11,"get_pointer_to_function_hook","","Get a pointer to the currently active hook for the given…",3,[[],["option",4]]],[11,"get_func_by_name","","Get a `Function` by name. The name must be the…",3,[[],["option",4]]],[11,"read","","Read a value `bits` bits long from memory at `addr`. Note…",3,[[],["result",6]]],[11,"write","","Write a value into memory at `addr`. Note that `val` can…",3,[[],["result",6]]],[11,"size","","Get the size of the `Type`, in bits.",3,[[["type",4]]]],[11,"size_opaque_aware","","Get the size of the `Type`, in bits.",3,[[["type",4],["project",3]],["option",4]]],[11,"fp_size","","Get the size of the `FPType`, in bits",3,[[["fptype",4]]]],[11,"get_offset_constant_index","","Get the offset (in bytes) of the element at the given…",3,[[["type",4]],["result",6]]],[11,"get_offset_bv_index","","Get the offset (in bytes) of the element at the given…",3,[[["type",4]],["result",6]]],[11,"add_mem_watchpoint","","Add a memory watchpoint. It will be enabled unless/until…",3,[[["watchpoint",3]]]],[11,"rm_mem_watchpoint","","Remove the memory watchpoint with the given `name`.",3,[[]]],[11,"disable_watchpoint","","Disable the memory watchpoint with the given `name`.…",3,[[]]],[11,"enable_watchpoint","","Enable the memory watchpoint(s) with the given name.",3,[[]]],[11,"allocate","","Allocate a value of size `bits`; return a pointer to the…",3,[[]]],[11,"get_allocation_size","","Get the size, in bits, of the allocation at the given…",3,[[],[["result",6],["option",4]]]],[11,"record_path_entry","","Record the current location as a `PathEntry` in the…",3,[[]]],[11,"get_path","","Get the `PathEntry`s that have been recorded, in order",3,[[],["vec",3]]],[11,"push_callsite","","Record entering a normal `Call` at the current location",3,[[["call",3]]]],[11,"push_invokesite","","Record entering the given `Invoke` at the current location",3,[[["invoke",3]]]],[11,"pop_callsite","","Record leaving the current function. Returns the…",3,[[],[["callsite",3],["option",4]]]],[11,"current_callstack_depth","","Returns the current callstack depth. `0` indicates we\'re…",3,[[]]],[11,"save_backtracking_point","","Save the current state, about to enter the `BasicBlock`…",3,[[["name",4]]]],[11,"revert_to_backtracking_point","","returns `Ok(true)` if the operation was successful,…",3,[[],["result",6]]],[11,"count_backtracking_points","","returns the number of saved backtracking points",3,[[]]],[11,"pretty_backtrace","","returns a `String` containing a formatted view of the…",3,[[],["string",3]]],[11,"pretty_path_llvm","","returns a `String` containing a formatted view of the full…",3,[[],["string",3]]],[11,"pretty_path_source","","returns a `String` containing a formatted view of the full…",3,[[],["string",3]]],[11,"pretty_path_interleaved","","returns a `String` containing a formatted view of the full…",3,[[],["string",3]]],[11,"demangle","","Attempt to demangle the given `funcname` as appropriate…",3,[[],["string",3]]],[11,"all_vars_in_cur_fn","","Get the most recent `BV` created for each `Name` in the…",3,[[]]],[11,"current_assignments_as_pretty_string","","returns a `String` describing a set of satisfying…",3,[[],[["result",6],["string",3]]]],[11,"full_error_message_with_context","","Returns a `String` describing both the error and the…",3,[[["error",4]],["string",3]]],[0,"watchpoints","","Structures for defining and processing memory watchpoints",null,null],[3,"Watchpoint","haybale::watchpoints","A `Watchpoint` describes a segment of memory to watch.",null,null],[3,"Watchpoints","","Stores information about watchpoints and performs…",null,null],[11,"new","","A memory watchpoint for the `bytes` bytes of memory at the…",25,[[]]],[11,"get_lower_bound","","Get the lower bound of the memory segment being watched…",25,[[]]],[11,"get_upper_bound","","Get the upper bound of the memory segment being watched…",25,[[]]],[11,"new","","Construct a new `Watchpoints` instance with no watchpoints.",26,[[]]],[11,"add","","Add a memory watchpoint. It will be enabled unless/until…",26,[[["watchpoint",3]]]],[11,"remove","","Remove the memory watchpoint with the given `name`.",26,[[]]],[11,"disable","","Disable the memory watchpoint with the given `name`.",26,[[]]],[11,"enable","","Enable the memory watchpoint(s) with the given name.",26,[[]]],[6,"Result","haybale","A type alias for convenience, similar to how…",null,null],[11,"unwrap_to_i8","","",7,[[]]],[11,"unwrap_to_i16","","",7,[[]]],[11,"unwrap_to_i32","","",7,[[]]],[11,"unwrap_to_i64","","",7,[[]]],[11,"unwrap_to_ptr","","",7,[[]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"into","","",9,[[]]],[11,"into_iter","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"reduce","","",9,[[],["option",4]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"to_string","","",4,[[],["string",3]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"to_string","","",5,[[],["string",3]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","haybale::config","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","haybale::backend","",27,[[]]],[11,"into","","",27,[[]]],[11,"to_owned","","",27,[[]]],[11,"clone_into","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"from","","",28,[[]]],[11,"into","","",28,[[]]],[11,"to_owned","","",28,[[]]],[11,"clone_into","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"from","haybale::callbacks","",18,[[]]],[11,"into","","",18,[[]]],[11,"to_owned","","",18,[[]]],[11,"clone_into","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from","haybale::cell_memory","",19,[[]]],[11,"into","","",19,[[]]],[11,"to_owned","","",19,[[]]],[11,"clone_into","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","haybale::function_hooks","",21,[[]]],[11,"into","","",21,[[]]],[11,"to_owned","","",21,[[]]],[11,"clone_into","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from","haybale::simple_memory","",22,[[]]],[11,"into","","",22,[[]]],[11,"to_owned","","",22,[[]]],[11,"clone_into","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from","haybale::solver_utils","",23,[[]]],[11,"into","","",23,[[]]],[11,"to_owned","","",23,[[]]],[11,"clone_into","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","","",24,[[]]],[11,"into","","",24,[[]]],[11,"to_owned","","",24,[[]]],[11,"clone_into","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"try_into","","",24,[[],["result",4]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"from","haybale::watchpoints","",25,[[]]],[11,"into","","",25,[[]]],[11,"to_owned","","",25,[[]]],[11,"clone_into","","",25,[[]]],[11,"to_string","","",25,[[],["string",3]]],[11,"try_from","","",25,[[],["result",4]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"from","","",26,[[]]],[11,"into","","",26,[[]]],[11,"to_owned","","",26,[[]]],[11,"clone_into","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"new_uninitialized","haybale::cell_memory","",19,[[["option",4],["rc",3],["btor",3]]]],[11,"new_zero_initialized","","",19,[[["option",4],["rc",3],["btor",3]]]],[11,"read","","",19,[[],["result",6]]],[11,"write","","",19,[[],["result",6]]],[11,"get_solver","","",19,[[],[["rc",3],["btor",3]]]],[11,"change_solver","","",19,[[["rc",3],["btor",3]]]],[11,"new_uninitialized","haybale::simple_memory","",22,[[["option",4],["rc",3],["btor",3]]]],[11,"new_zero_initialized","","",22,[[["option",4],["rc",3],["btor",3]]]],[11,"read","","",22,[[],["result",6]]],[11,"write","","",22,[[],["result",6]]],[11,"get_solver","","",22,[[],[["rc",3],["btor",3]]]],[11,"change_solver","","",22,[[["rc",3],["btor",3]]]],[11,"from","haybale","",1,[[["location",3]],["locationdescription",3]]],[11,"next","","",9,[[],["option",4]]],[11,"clone","haybale::config","",10,[[],["config",3]]],[11,"clone","","",12,[[],["nullpointerchecking",4]]],[11,"clone","","",13,[[],["concretize",4]]],[11,"clone","haybale","",5,[[],["error",4]]],[11,"clone","","",6,[[],["returnvalue",4]]],[11,"clone","haybale::backend","",27,[[],["cellmemorybackend",3]]],[11,"clone","","",28,[[],["defaultbackend",3]]],[11,"clone","haybale::callbacks","",18,[[],["callbacks",3]]],[11,"clone","haybale::cell_memory","",19,[[],["memory",3]]],[11,"clone","haybale::config","",11,[[],["demangling",4]]],[11,"clone","haybale::function_hooks","",21,[[],["functionhooks",3]]],[11,"clone","haybale::simple_memory","",22,[[],["memory",3]]],[11,"clone","haybale::solver_utils","",23,[[],["possiblesolutions",4]]],[11,"clone","","",24,[[],["solutioncount",4]]],[11,"clone","haybale","",3,[[],["state",3]]],[11,"clone","","",1,[[],["locationdescription",3]]],[11,"clone","","",4,[[],["bbinstrindex",4]]],[11,"clone","","",2,[[],["pathentry",3]]],[11,"clone","","",0,[[],["location",3]]],[11,"clone","haybale::watchpoints","",25,[[],["watchpoint",3]]],[11,"clone","","",26,[[],["watchpoints",3]]],[11,"clone","haybale","",7,[[],["solutionvalue",4]]],[11,"default","haybale::config","Default values for all configuration parameters.",10,[[]]],[11,"default","haybale::callbacks","",18,[[]]],[11,"default","haybale::function_hooks","Provides predefined hooks for common functions. (At the…",21,[[]]],[11,"default","haybale::watchpoints","",26,[[],["watchpoints",3]]],[11,"cmp","haybale","",1,[[["locationdescription",3]],["ordering",4]]],[11,"cmp","","",4,[[["bbinstrindex",4]],["ordering",4]]],[11,"eq","haybale::config","",12,[[["nullpointerchecking",4]]]],[11,"eq","","",13,[[["concretize",4]]]],[11,"ne","","",13,[[["concretize",4]]]],[11,"eq","haybale","",5,[[["error",4]]]],[11,"ne","","",5,[[["error",4]]]],[11,"eq","","",6,[[["returnvalue",4]]]],[11,"ne","","",6,[[["returnvalue",4]]]],[11,"eq","haybale::backend","",27,[[["cellmemorybackend",3]]]],[11,"eq","","",28,[[["defaultbackend",3]]]],[11,"eq","haybale::cell_memory","",19,[[]]],[11,"eq","haybale::config","",11,[[["demangling",4]]]],[11,"eq","haybale::simple_memory","",22,[[["memory",3]]]],[11,"ne","","",22,[[["memory",3]]]],[11,"eq","haybale::solver_utils","",23,[[["possiblesolutions",4]]]],[11,"ne","","",23,[[["possiblesolutions",4]]]],[11,"eq","","",24,[[["solutioncount",4]]]],[11,"ne","","",24,[[["solutioncount",4]]]],[11,"eq","haybale","",1,[[["locationdescription",3]]]],[11,"ne","","",1,[[["locationdescription",3]]]],[11,"eq","","",4,[[["bbinstrindex",4]]]],[11,"ne","","",4,[[["bbinstrindex",4]]]],[11,"eq","","",2,[[["pathentry",3]]]],[11,"ne","","",2,[[["pathentry",3]]]],[11,"eq","","",0,[[]]],[11,"eq","haybale::watchpoints","",25,[[["watchpoint",3]]]],[11,"ne","","",25,[[["watchpoint",3]]]],[11,"eq","haybale","",7,[[["solutionvalue",4]]]],[11,"ne","","",7,[[["solutionvalue",4]]]],[11,"partial_cmp","","",1,[[["locationdescription",3]],[["option",4],["ordering",4]]]],[11,"lt","","",1,[[["locationdescription",3]]]],[11,"le","","",1,[[["locationdescription",3]]]],[11,"gt","","",1,[[["locationdescription",3]]]],[11,"ge","","",1,[[["locationdescription",3]]]],[11,"partial_cmp","","",4,[[["bbinstrindex",4]],[["option",4],["ordering",4]]]],[11,"lt","","",4,[[["bbinstrindex",4]]]],[11,"le","","",4,[[["bbinstrindex",4]]]],[11,"gt","","",4,[[["bbinstrindex",4]]]],[11,"ge","","",4,[[["bbinstrindex",4]]]],[11,"fmt","haybale::config","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","haybale","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::backend","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::cell_memory","",19,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::config","",11,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::simple_memory","",22,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::solver_utils","",23,[[["formatter",3]],["result",6]]],[11,"fmt","","",24,[[["formatter",3]],["result",6]]],[11,"fmt","haybale","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::watchpoints","",25,[[["formatter",3]],["result",6]]],[11,"fmt","haybale","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::watchpoints","",25,[[["formatter",3]],["result",6]]],[11,"hash","haybale","",6,[[]]],[11,"hash","","",1,[[]]],[11,"hash","","",4,[[]]],[11,"hash","","",0,[[]]],[11,"hash","haybale::watchpoints","",25,[[]]],[11,"from_iter","haybale::solver_utils","Create a `PossibleSolutions::Exactly` from the contents of…",23,[[["intoiterator",8]]]],[11,"from_iter","haybale::watchpoints","",26,[[["intoiterator",8]]]]],"p":[[3,"Location"],[3,"LocationDescription"],[3,"PathEntry"],[3,"State"],[4,"BBInstrIndex"],[4,"Error"],[4,"ReturnValue"],[4,"SolutionValue"],[3,"Project"],[3,"ExecutionManager"],[3,"Config"],[4,"Demangling"],[4,"NullPointerChecking"],[4,"Concretize"],[8,"Backend"],[8,"SolverRef"],[8,"BV"],[8,"Memory"],[3,"Callbacks"],[3,"Memory"],[8,"IsCall"],[3,"FunctionHooks"],[3,"Memory"],[4,"PossibleSolutions"],[4,"SolutionCount"],[3,"Watchpoint"],[3,"Watchpoints"],[3,"CellMemoryBackend"],[3,"DefaultBackend"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);