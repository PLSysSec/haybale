var searchIndex = JSON.parse('{\
"haybale":{"doc":"For an introduction to the crate and how to get started, …","i":[[0,"config","haybale","The <code>Config</code> structure for configuring <code>haybale</code>, and other …",null,null],[4,"Demangling","haybale::config","Enum used for the <code>demangling</code> option in <code>Config</code>.",null,null],[13,"NoDemangling","","Don\'t try to demangle",0,null],[13,"CPP","","Try to demangle using the C++ demangler (suitable for …",0,null],[13,"Rust","","Try to demangle using the Rust demangler (suitable for …",0,null],[3,"Config","","Various settings which affect how the symbolic execution …",null,null],[12,"loop_bound","","Maximum number of times to execute any given line of LLVM …",1,null],[12,"max_callstack_depth","","Maximum callstack depth to allow when symbolically …",1,null],[12,"solver_query_timeout","","Maximum amount of time to allow for any single solver …",1,null],[12,"null_pointer_checking","","Should we check each memory access for possible <code>NULL</code> …",1,null],[12,"concretize_memcpy_lengths","","When encountering a <code>memcpy</code>, <code>memset</code>, or <code>memmove</code> with …",1,null],[12,"max_memcpy_length","","Maximum supported length of a <code>memcpy</code>, <code>memset</code>, or <code>memmove</code> …",1,null],[12,"squash_unsats","","<code>Error::Unsat</code> is an error type which is used internally, …",1,null],[12,"trust_llvm_assumes","","When encountering the <code>llvm.assume()</code> intrinsic, should we …",1,null],[12,"function_hooks","","The set of currently active function hooks; see …",1,null],[12,"callbacks","","The set of currently active callbacks; see <code>Callbacks</code> for …",1,null],[12,"initial_mem_watchpoints","","The initial memory watchpoints when a <code>State</code> is created …",1,null],[12,"demangling","","Controls the (attempted) demangling of function names in …",1,null],[12,"print_source_info","","If <code>true</code>, then <code>haybale</code> will attempt to print source …",1,null],[12,"print_module_name","","If <code>true</code>, then <code>haybale</code> will include the module name along …",1,null],[4,"NullPointerChecking","","Enum used for the <code>null_pointer_checking</code> option in <code>Config</code>.",null,null],[13,"Simple","","All memory accesses will be checked to ensure their …",2,null],[13,"SplitPath","","All memory accesses will be checked to ensure their …",2,null],[13,"None","","Memory accesses will not be checked for <code>NULL</code> addresses. …",2,null],[4,"Concretize","","Enum used for the <code>concretize_memcpy_lengths</code> option in …",null,null],[13,"Symbolic","","Handle everything fully symbolically - that is, have the …",3,null],[13,"Arbitrary","","Pick one possible value arbitrarily. Often this may …",3,null],[13,"Prefer","","Prefer the given <code>u64</code> value if it is a possible value. …",3,null],[13,"Maximum","","Choose the maximum possible value. <code>Maximum</code> will be …",3,null],[13,"Minimum","","Choose the minimum possible value. <code>Minimum</code> will be …",3,null],[11,"new","","Creates a new <code>Config</code> with defaults for all the options, …",1,[[]]],[0,"alloc_utils","haybale","Utility functions for performing memory allocation. These …",null,null],[5,"malloc","haybale::alloc_utils","Allocate a number of bytes given by the <code>Operand</code>.",null,[[["state",3],["operand",4]],["result",6]]],[5,"zalloc","","Allocate a number of bytes given by the <code>Operand</code>. The …",null,[[["state",3],["operand",4]],["result",6]]],[5,"calloc","","Allocate a number of bytes given by <code>a</code> times <code>b</code>, where <code>a</code> …",null,[[["state",3],["operand",4]],["result",6]]],[5,"realloc","","Reallocate the given <code>addr</code> to be at least the number of …",null,[[["state",3],["operand",4]],["result",6]]],[0,"backend","haybale","Traits which abstract over the backend (BV types, memory …",null,null],[8,"Backend","haybale::backend","A <code>Backend</code> is just a collection of types which together …",null,null],[16,"SolverRef","","",4,null],[16,"BV","","",4,null],[16,"Memory","","",4,null],[8,"SolverRef","","Trait for something which acts as a reference to a …",null,null],[16,"BV","","",5,null],[16,"Array","","",5,null],[10,"new","","Create a new <code>Btor</code> instance, initialize it as necessary, …",5,[[]]],[10,"duplicate","","As opposed to <code>clone()</code> which merely clones the reference, …",5,[[]]],[10,"match_bv","","Given a <code>BV</code> originally created for any <code>SolverRef</code>, get the …",5,[[],["option",4]]],[10,"match_array","","Given an <code>Array</code> originally created for any <code>SolverRef</code>, get …",5,[[],["option",4]]],[8,"BV","","Trait for things which can act like bitvectors.",null,null],[16,"SolverRef","","",6,null],[10,"new","","",6,[[["u32",15],["option",4],["str",15]]]],[10,"from_bool","","",6,[[["bool",15]]]],[10,"from_i32","","",6,[[["u32",15],["i32",15]]]],[10,"from_u32","","",6,[[["u32",15]]]],[10,"from_i64","","",6,[[["i64",15],["u32",15]]]],[10,"from_u64","","",6,[[["u32",15],["u64",15]]]],[10,"zero","","",6,[[["u32",15]]]],[10,"one","","",6,[[["u32",15]]]],[10,"ones","","",6,[[["u32",15]]]],[10,"from_binary_str","","",6,[[["str",15]]]],[10,"from_dec_str","","",6,[[["u32",15],["str",15]]]],[10,"from_hex_str","","",6,[[["u32",15],["str",15]]]],[10,"as_binary_str","","",6,[[],[["option",4],["string",3]]]],[10,"as_u64","","",6,[[],[["option",4],["u64",15]]]],[10,"as_bool","","",6,[[],[["bool",15],["option",4]]]],[10,"get_a_solution","","",6,[[],[["result",6],["bvsolution",3]]]],[10,"get_solver","","",6,[[]]],[10,"get_id","","",6,[[],["i32",15]]],[10,"get_width","","",6,[[],["u32",15]]],[10,"get_symbol","","",6,[[],[["option",4],["str",15]]]],[10,"set_symbol","","",6,[[["option",4],["str",15]]]],[10,"is_const","","",6,[[],["bool",15]]],[10,"has_same_width","","",6,[[],["bool",15]]],[10,"assert","","",6,[[],["result",6]]],[10,"is_failed_assumption","","",6,[[],["bool",15]]],[10,"_eq","","",6,[[]]],[10,"_ne","","",6,[[]]],[10,"add","","",6,[[]]],[10,"sub","","",6,[[]]],[10,"mul","","",6,[[]]],[10,"udiv","","",6,[[]]],[10,"sdiv","","",6,[[]]],[10,"urem","","",6,[[]]],[10,"srem","","",6,[[]]],[10,"smod","","",6,[[]]],[10,"inc","","",6,[[]]],[10,"dec","","",6,[[]]],[10,"neg","","",6,[[]]],[10,"uaddo","","",6,[[]]],[10,"saddo","","",6,[[]]],[10,"usubo","","",6,[[]]],[10,"ssubo","","",6,[[]]],[10,"umulo","","",6,[[]]],[10,"smulo","","",6,[[]]],[10,"sdivo","","",6,[[]]],[10,"not","","",6,[[]]],[10,"and","","",6,[[]]],[10,"or","","",6,[[]]],[10,"xor","","",6,[[]]],[10,"nand","","",6,[[]]],[10,"nor","","",6,[[]]],[10,"xnor","","",6,[[]]],[10,"sll","","",6,[[]]],[10,"srl","","",6,[[]]],[10,"sra","","",6,[[]]],[10,"rol","","",6,[[]]],[10,"ror","","",6,[[]]],[10,"redand","","",6,[[]]],[10,"redor","","",6,[[]]],[10,"redxor","","",6,[[]]],[10,"ugt","","",6,[[]]],[10,"ugte","","",6,[[]]],[10,"sgt","","",6,[[]]],[10,"sgte","","",6,[[]]],[10,"ult","","",6,[[]]],[10,"ulte","","",6,[[]]],[10,"slt","","",6,[[]]],[10,"slte","","",6,[[]]],[10,"zext","","",6,[[["u32",15]]]],[10,"sext","","",6,[[["u32",15]]]],[10,"slice","","",6,[[["u32",15]]]],[10,"concat","","",6,[[]]],[10,"repeat","","",6,[[["u32",15]]]],[10,"iff","","",6,[[]]],[10,"implies","","",6,[[]]],[10,"cond_bv","","",6,[[]]],[11,"zero_extend_to_bits","","Zero-extend a <code>BV</code> to the specified number of bits. The …",6,[[["u32",15]]]],[11,"sign_extend_to_bits","","Sign-extend a <code>BV</code> to the specified number of bits. The …",6,[[["u32",15]]]],[11,"uadds","","Saturating addition, unsigned. The result will be the …",6,[[]]],[11,"sadds","","Saturating addition, signed. The result will be the same …",6,[[]]],[11,"usubs","","Saturating subtraction, unsigned. The result will be the …",6,[[]]],[11,"ssubs","","Saturating subtraction, signed. The result will be the …",6,[[]]],[8,"Memory","","Trait for things which can act like \'memories\', that is, …",null,null],[16,"SolverRef","","",7,null],[16,"Index","","",7,null],[16,"Value","","",7,null],[10,"new_uninitialized","","A new <code>Memory</code>, whose contents at all addresses are …",7,[[["u32",15],["bool",15],["option",4],["str",15]]]],[10,"new_zero_initialized","","A new <code>Memory</code>, whose contents at all addresses are …",7,[[["u32",15],["bool",15],["option",4],["str",15]]]],[10,"read","","Read any number (>0) of bits of memory, at any alignment. …",7,[[["u32",15]],["result",6]]],[10,"write","","Write any number (>0) of bits of memory, at any alignment.",7,[[],["result",6]]],[10,"get_solver","","Get a reference to the solver instance this <code>Memory</code> …",7,[[]]],[10,"change_solver","","Adapt the <code>Memory</code> to a new solver instance.",7,[[]]],[3,"CellMemoryBackend","","",null,null],[3,"DefaultBackend","","",null,null],[0,"callbacks","haybale","Functions and structures for defining and activating …",null,null],[3,"Callbacks","haybale::callbacks","",null,null],[11,"add_instruction_callback","","Add an instruction callback. <code>haybale</code> will call the …",8,[[]]],[11,"add_terminator_callback","","Add a terminator callback. <code>haybale</code> will call the provided …",8,[[]]],[0,"cell_memory","haybale","Implementation of a <code>Memory</code> based on a Boolector array and …",null,null],[3,"Memory","haybale::cell_memory","",null,null],[18,"INDEX_BITS","","",9,null],[18,"CELL_BITS","","",9,null],[18,"BITS_IN_BYTE","","",9,null],[18,"LOG_BITS_IN_BYTE","","",9,null],[18,"CELL_BYTES","","",9,null],[18,"LOG_CELL_BYTES","","",9,null],[18,"CELL_OFFSET_MASK","","",9,null],[11,"new_uninitialized","","A new <code>Memory</code>, whose contents at all addresses are …",9,[[["btor",3],["u32",15],["bool",15],["rc",3],["option",4],["str",15]]]],[11,"new_zero_initialized","","A new <code>Memory</code>, whose contents at all addresses are …",9,[[["btor",3],["u32",15],["bool",15],["rc",3],["option",4],["str",15]]]],[11,"get_solver","","Get a reference to the <code>Btor</code> instance this <code>Memory</code> belongs …",9,[[],[["btor",3],["rc",3]]]],[11,"change_solver","","Adapt the <code>Memory</code> to a new <code>Btor</code> instance.",9,[[["btor",3],["rc",3]]]],[11,"read","","Read any number (>0) of bits of memory, at any alignment. …",9,[[["u32",15],["bv",3]],[["bv",3],["result",6]]]],[11,"write","","Write any number (>0) of bits of memory, at any alignment.",9,[[["bv",3],["rc",3],["bv",3]],["result",6]]],[11,"maybe_demangle","haybale::config","Attempts to demangle the given function name, as …",0,[[["str",15]],["string",3]]],[11,"autodetect","","Guesses an appropriate <code>Demangling</code> for the given <code>Project</code>.",0,[[["project",3]]]],[0,"function_hooks","haybale","Functions and structures for defining and activating …",null,null],[3,"FunctionHooks","haybale::function_hooks","A set of function hooks, which will be executed instead …",null,null],[6,"Argument","","An <code>Argument</code> represents a single argument to a called …",null,null],[8,"IsCall","","<code>IsCall</code> exists to unify the commonalities between LLVM <code>Call</code>…",null,null],[10,"get_called_func","","",10,[[],["either",4]]],[10,"get_arguments","","",10,[[],["vec",3]]],[10,"get_return_attrs","","",10,[[],["vec",3]]],[10,"get_fn_attrs","","",10,[[],["vec",3]]],[10,"get_calling_convention","","",10,[[],["callingconvention",4]]],[11,"new","","Create a blank <code>FunctionHooks</code> instance with no function …",11,[[]]],[11,"add","","Adds a function hook. The <code>hook</code> will be executed instead …",11,[[]]],[11,"add_cpp_demangled","","Exactly like <code>add()</code>, but takes the (C++) <em>demangled</em> name of …",11,[[]]],[11,"add_rust_demangled","","Exactly like <code>add()</code>, but takes the (Rust) <em>demangled</em> name …",11,[[]]],[11,"add_inline_asm_hook","","Add a hook to be used for calls to inline assembly. This …",11,[[],["bool",15]]],[11,"add_default_hook","","Add a hook to be used if no other definition or hook is …",11,[[],["bool",15]]],[11,"remove","","Removes the function hook for the given function, which …",11,[[["str",15]]]],[11,"remove_cpp_demangled","","Removes the function hook for the given function, which …",11,[[["str",15]]]],[11,"remove_rust_demangled","","Removes the function hook for the given function, which …",11,[[["str",15]]]],[11,"remove_inline_asm_hook","","Removes the function hook used for calls to inline …",11,[[]]],[11,"remove_default_hook","","Removes the default function hook which was added with …",11,[[]]],[11,"is_hooked","","Determine whether there is an active hook for the given …",11,[[["str",15]],["bool",15]]],[11,"has_inline_asm_hook","","Is there currently an inline asm hook active? (See …",11,[[],["bool",15]]],[11,"has_default_hook","","Is there currently a default hook active? (See …",11,[[],["bool",15]]],[5,"generic_stub_hook","","This hook ignores the function arguments and returns an …",null,[[["state",3],["iscall",8]],[["returnvalue",4],["result",6]]]],[5,"abort_hook","","This hook ignores the function arguments and returns …",null,[[["state",3],["iscall",8]],[["returnvalue",4],["result",6]]]],[0,"hook_utils","haybale","Utility functions for performing memset or memcpy …",null,null],[5,"memset","haybale::hook_utils","Set <code>num_bytes</code> bytes of memory at address <code>addr</code> each to the …",null,[[["state",3],["operand",4]],["result",6]]],[5,"memset_bv","","Just like <code>memset()</code> above, but takes <code>BV</code>s instead of <code>Operand</code>…",null,[[["state",3]],["result",6]]],[5,"memcpy","","Copies <code>num_bytes</code> bytes of memory from address <code>src</code> to …",null,[[["state",3],["operand",4]],["result",6]]],[5,"memcpy_bv","","Just like <code>memcpy()</code> above, but takes <code>BV</code>s instead of <code>Operand</code>…",null,[[["state",3]],["result",6]]],[0,"simple_memory","haybale","Simple implementation of a <code>Memory</code> based on a Boolector …",null,null],[3,"Memory","haybale::simple_memory","",null,null],[18,"CELL_BITS","","",12,null],[18,"BITS_IN_BYTE","","",12,null],[18,"LOG_BITS_IN_BYTE","","",12,null],[18,"CELL_BYTES","","",12,null],[11,"new_uninitialized","","A new <code>Memory</code>, whose contents at all addresses are …",12,[[["btor",3],["u32",15],["bool",15],["rc",3],["option",4],["str",15]]]],[11,"new_zero_initialized","","A new <code>Memory</code>, whose contents at all addresses are …",12,[[["btor",3],["u32",15],["bool",15],["rc",3],["option",4],["str",15]]]],[11,"get_solver","","Get a reference to the <code>Btor</code> instance this <code>Memory</code> belongs …",12,[[],[["btor",3],["rc",3]]]],[11,"change_solver","","Adapt the <code>Memory</code> to a new <code>Btor</code> instance.",12,[[["btor",3],["rc",3]]]],[11,"read","","Read any number (>0) of bits of memory, at any alignment. …",12,[[["u32",15],["bv",3]],[["bv",3],["result",6]]]],[11,"write","","Write any number (>0) of bits of memory, at any alignment.",12,[[["bv",3],["rc",3],["bv",3]],["result",6]]],[0,"solver_utils","haybale","Simple utilities for interacting with the solver",null,null],[5,"sat","haybale::solver_utils","Returns <code>true</code> if current constraints are satisfiable, <code>false</code>…",null,[[["btor",3]],[["bool",15],["result",6]]]],[5,"sat_with_extra_constraints","","Returns <code>true</code> if the current constraints plus the …",null,[[["btor",3]],[["bool",15],["result",6]]]],[5,"bvs_must_be_equal","","Returns <code>true</code> if under the current constraints, <code>a</code> and <code>b</code> …",null,[[["btor",3]],[["bool",15],["result",6]]]],[5,"bvs_can_be_equal","","Returns <code>true</code> if under the current constraints, <code>a</code> and <code>b</code> …",null,[[["btor",3]],[["bool",15],["result",6]]]],[4,"PossibleSolutions","","",null,null],[13,"Exactly","","This is exactly the set of possible solutions; there are …",13,null],[13,"AtLeast","","All of the solutions in this set are possible solutions, …",13,null],[11,"empty","","Create a new, empty, <code>PossibleSolutions</code> (representing no …",13,[[]]],[11,"exactly_one","","Create a new <code>PossibleSolutions</code> representing exactly one …",13,[[]]],[11,"exactly_two","","Create a new <code>PossibleSolutions</code> repesenting exactly two …",13,[[]]],[11,"as_u64_solutions","","Convert a <code>PossibleSolutions</code> over <code>BVSolution</code> into a …",13,[[],[["option",4],["possiblesolutions",4]]]],[4,"SolutionCount","","",null,null],[13,"Exactly","","There are exactly this many solutions",14,null],[13,"AtLeast","","There are at least this many solutions",14,null],[11,"count","","Get a count of how many possible solutions there are.",13,[[],["solutioncount",4]]],[5,"get_possible_solutions_for_bv","","Get a description of the possible solutions for the <code>BV</code>.",null,[[["usize",15]],[["possiblesolutions",4],["result",6]]]],[5,"max_possible_solution_for_bv_as_u64","","Get the maximum possible solution for the <code>BV</code>: that is, …",null,[[],[["result",6],["option",4]]]],[5,"min_possible_solution_for_bv_as_u64","","Get the minimum possible solution for the <code>BV</code>: that is, …",null,[[],[["result",6],["option",4]]]],[5,"max_possible_solution_for_bv_as_binary_str","","Get the maximum possible solution for the <code>BV</code>: that is, …",null,[[],[["option",4],["result",6]]]],[5,"min_possible_solution_for_bv_as_binary_str","","Get the minimum possible solution for the <code>BV</code>: that is, …",null,[[],[["option",4],["result",6]]]],[0,"watchpoints","haybale","Structures for defining and processing memory watchpoints",null,null],[3,"Watchpoint","haybale::watchpoints","A <code>Watchpoint</code> describes a segment of memory to watch.",null,null],[11,"new","","A memory watchpoint for the <code>bytes</code> bytes of memory at the …",15,[[["u64",15]]]],[11,"get_lower_bound","","Get the lower bound of the memory segment being watched …",15,[[],["u64",15]]],[11,"get_upper_bound","","Get the upper bound of the memory segment being watched …",15,[[],["u64",15]]],[3,"Watchpoints","","Stores information about watchpoints and performs …",null,null],[11,"new","","Construct a new <code>Watchpoints</code> instance with no watchpoints.",16,[[]]],[11,"add","","Add a memory watchpoint. It will be enabled unless/until …",16,[[["watchpoint",3]],["bool",15]]],[11,"remove","","Remove the memory watchpoint with the given <code>name</code>.",16,[[["str",15]],["bool",15]]],[11,"disable","","Disable the memory watchpoint with the given <code>name</code>.",16,[[["str",15]],["bool",15]]],[11,"enable","","Enable the memory watchpoint(s) with the given name.",16,[[["str",15]],["bool",15]]],[3,"Project","haybale","A <code>Project</code> is a collection of LLVM code to be explored, …",null,null],[4,"BBInstrIndex","","Denotes either a particular instruction in a basic block, …",null,null],[13,"Instr","","Index of the instruction within the basic block. …",17,null],[13,"Terminator","","Indicates the basic block terminator (not one of its …",17,null],[3,"Location","","Fully describes a code location within the LLVM IR.",null,null],[12,"module","","",18,null],[12,"func","","",18,null],[12,"bb","","",18,null],[12,"instr","","",18,null],[12,"source_loc","","Source location which this IR location corresponds to, if …",18,null],[3,"LocationDescription","","Describes a location in LLVM IR in a format more suitable …",null,null],[12,"modname","","",19,null],[12,"funcname","","",19,null],[12,"bbname","","",19,null],[12,"instr","","",19,null],[12,"source_loc","","",19,null],[3,"PathEntry","","Describes one segment of a path through the LLVM IR. The …",null,null],[12,"0","","",20,null],[3,"State","","A <code>State</code> describes the full program state at a given …",null,null],[12,"solver","","Reference to the solver instance being used",21,null],[12,"config","","The configuration being used",21,null],[12,"proj","","Referece to the <code>Project</code> being used",21,null],[12,"cur_loc","","Indicates the instruction which is currently being …",21,null],[5,"symex_function","","Begin symbolic execution of the function named <code>funcname</code>, …",null,[[["config",3],["backend",8],["vec",3],["option",4],["project",3],["str",15]],[["executionmanager",3],["result",6]]]],[3,"ExecutionManager","","An <code>ExecutionManager</code> allows you to symbolically explore …",null,null],[4,"Error","","Error types used throughout this crate.",null,null],[13,"Unsat","","While performing an operation, we discovered the current …",22,null],[13,"LoopBoundExceeded","","The current path has exceeded the configured <code>loop_bound</code> …",22,null],[13,"NullPointerDereference","","The current path has attempted to dereference a null …",22,null],[13,"FunctionNotFound","","Processing a call of a function with the given name, but …",22,null],[13,"SolverError","","The solver returned this processing error while …",22,null],[13,"UnsupportedInstruction","","Encountered an LLVM instruction which is not currently …",22,null],[13,"MalformedInstruction","","Encountered an LLVM instruction which was malformed, or …",22,null],[13,"UnreachableInstruction","","Reached an LLVM <code>Unreachable</code> instruction",22,null],[13,"FailedToResolveFunctionPointer","","Failed to interpret some symbolic value (<code>BV</code>) as a …",22,null],[13,"HookReturnValueMismatch","","The hook for some function returned a value which didn\'t …",22,null],[13,"OtherError","","Some kind of error which doesn\'t fall into one of the …",22,null],[6,"Result","","A type alias for convenience, similar to how …",null,null],[4,"ParameterVal","","",null,null],[13,"Unconstrained","","The parameter can have any value whatsoever. (The …",23,null],[13,"ExactValue","","The parameter will have this exact value.",23,null],[13,"Range","","The parameter can have any value in this range …",23,null],[13,"NonNullPointer","","The parameter will have a non-null value, but otherwise …",23,null],[13,"PointerToAllocated","","The parameter will point to allocated memory, with the …",23,null],[4,"ReturnValue","","A simple enum describing the value returned from a …",null,null],[13,"Return","","The function or call returns this value",24,null],[13,"ReturnVoid","","The function or call returns void",24,null],[13,"Throw","","The function or call throws this value (using the LLVM …",24,null],[13,"Abort","","The function or call aborts without ever returning (e.g., …",24,null],[5,"get_path_length","","Returns the number of LLVM instructions in a passed path. …",null,[[["vec",3]],["usize",15]]],[4,"SolutionValue","","A simple enum describing either an integer value or a …",null,null],[13,"I8","","",25,null],[13,"I16","","",25,null],[13,"I32","","",25,null],[13,"I64","","",25,null],[13,"Ptr","","",25,null],[11,"unwrap_to_i8","","",25,[[],["i8",15]]],[11,"unwrap_to_i16","","",25,[[],["i16",15]]],[11,"unwrap_to_i32","","",25,[[],["i32",15]]],[11,"unwrap_to_i64","","",25,[[],["i64",15]]],[11,"unwrap_to_ptr","","",25,[[],["u64",15]]],[5,"find_zero_of_func","","Given a function, find values of its inputs such that it …",null,[[["config",3],["vec",3],["option",4],["project",3],["defaultbackend",3],["str",15]],[["option",4],["result",4],["string",3]]]],[5,"get_possible_return_values_of_func","","Get a description of the possible return values of a …",null,[[["u32",15],["usize",15],["vec",3],["option",4],["defaultbackend",3],["config",3],["str",15],["option",4],["project",3]],[["returnvalue",4],["possiblesolutions",4]]]],[11,"from","","",26,[[]]],[11,"into","","",26,[[]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from","","",27,[[]]],[11,"into","","",27,[[]]],[11,"into_iter","","",27,[[]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"reduce","","",27,[[],["option",4]]],[11,"from","haybale::config","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","haybale","",22,[[]]],[11,"into","","",22,[[]]],[11,"to_owned","","",22,[[]]],[11,"clone_into","","",22,[[]]],[11,"to_string","","",22,[[],["string",3]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"try_into","","",22,[[],["result",4]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from","","",23,[[]]],[11,"into","","",23,[[]]],[11,"to_owned","","",23,[[]]],[11,"clone_into","","",23,[[]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","","",24,[[]]],[11,"into","","",24,[[]]],[11,"to_owned","","",24,[[]]],[11,"clone_into","","",24,[[]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"try_into","","",24,[[],["result",4]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"from","haybale::backend","",28,[[]]],[11,"into","","",28,[[]]],[11,"to_owned","","",28,[[]]],[11,"clone_into","","",28,[[]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"from","","",29,[[]]],[11,"into","","",29,[[]]],[11,"to_owned","","",29,[[]]],[11,"clone_into","","",29,[[]]],[11,"borrow","","",29,[[]]],[11,"borrow_mut","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"try_into","","",29,[[],["result",4]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"from","haybale::callbacks","",8,[[]]],[11,"into","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","haybale::cell_memory","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","haybale::function_hooks","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","haybale::simple_memory","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","haybale::solver_utils","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from","haybale","",21,[[]]],[11,"into","","",21,[[]]],[11,"to_owned","","",21,[[]]],[11,"clone_into","","",21,[[]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from","","",19,[[]]],[11,"into","","",19,[[]]],[11,"to_owned","","",19,[[]]],[11,"clone_into","","",19,[[]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","","",17,[[]]],[11,"into","","",17,[[]]],[11,"to_owned","","",17,[[]]],[11,"clone_into","","",17,[[]]],[11,"to_string","","",17,[[],["string",3]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from","","",20,[[]]],[11,"into","","",20,[[]]],[11,"to_owned","","",20,[[]]],[11,"clone_into","","",20,[[]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from","","",18,[[]]],[11,"into","","",18,[[]]],[11,"to_owned","","",18,[[]]],[11,"clone_into","","",18,[[]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from","haybale::watchpoints","",15,[[]]],[11,"into","","",15,[[]]],[11,"to_owned","","",15,[[]]],[11,"clone_into","","",15,[[]]],[11,"to_string","","",15,[[],["string",3]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"from","","",16,[[]]],[11,"into","","",16,[[]]],[11,"to_owned","","",16,[[]]],[11,"clone_into","","",16,[[]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"from","haybale","",25,[[]]],[11,"into","","",25,[[]]],[11,"to_owned","","",25,[[]]],[11,"clone_into","","",25,[[]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"try_into","","",25,[[],["result",4]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"new_uninitialized","haybale::cell_memory","",9,[[["btor",3],["u32",15],["bool",15],["rc",3],["option",4],["str",15]]]],[11,"new_zero_initialized","","",9,[[["btor",3],["u32",15],["bool",15],["rc",3],["option",4],["str",15]]]],[11,"read","","",9,[[["u32",15]],["result",6]]],[11,"write","","",9,[[],["result",6]]],[11,"get_solver","","",9,[[],[["btor",3],["rc",3]]]],[11,"change_solver","","",9,[[["btor",3],["rc",3]]]],[11,"new_uninitialized","haybale::simple_memory","",12,[[["btor",3],["u32",15],["bool",15],["rc",3],["option",4],["str",15]]]],[11,"new_zero_initialized","","",12,[[["btor",3],["u32",15],["bool",15],["rc",3],["option",4],["str",15]]]],[11,"read","","",12,[[["u32",15]],["result",6]]],[11,"write","","",12,[[],["result",6]]],[11,"get_solver","","",12,[[],[["btor",3],["rc",3]]]],[11,"change_solver","","",12,[[["btor",3],["rc",3]]]],[11,"from","haybale","",19,[[["location",3]],["locationdescription",3]]],[11,"next","","",27,[[],["option",4]]],[11,"clone","haybale::config","",1,[[],["config",3]]],[11,"clone","","",2,[[],["nullpointerchecking",4]]],[11,"clone","","",3,[[],["concretize",4]]],[11,"clone","haybale","",22,[[],["error",4]]],[11,"clone","","",23,[[],["parameterval",4]]],[11,"clone","","",24,[[],["returnvalue",4]]],[11,"clone","haybale::backend","",28,[[],["cellmemorybackend",3]]],[11,"clone","","",29,[[],["defaultbackend",3]]],[11,"clone","haybale::callbacks","",8,[[],["callbacks",3]]],[11,"clone","haybale::cell_memory","",9,[[],["memory",3]]],[11,"clone","haybale::config","",0,[[],["demangling",4]]],[11,"clone","haybale::function_hooks","",11,[[],["functionhooks",3]]],[11,"clone","haybale::simple_memory","",12,[[],["memory",3]]],[11,"clone","haybale::solver_utils","",13,[[],["possiblesolutions",4]]],[11,"clone","","",14,[[],["solutioncount",4]]],[11,"clone","haybale","",21,[[],["state",3]]],[11,"clone","","",19,[[],["locationdescription",3]]],[11,"clone","","",17,[[],["bbinstrindex",4]]],[11,"clone","","",20,[[],["pathentry",3]]],[11,"clone","","",18,[[],["location",3]]],[11,"clone","haybale::watchpoints","",15,[[],["watchpoint",3]]],[11,"clone","","",16,[[],["watchpoints",3]]],[11,"clone","haybale","",25,[[],["solutionvalue",4]]],[11,"default","haybale::config","Default values for all configuration parameters.",1,[[]]],[11,"default","haybale","",23,[[]]],[11,"default","haybale::callbacks","",8,[[]]],[11,"default","haybale::function_hooks","Provides predefined hooks for common functions. (At the …",11,[[]]],[11,"default","haybale::watchpoints","",16,[[],["watchpoints",3]]],[11,"cmp","haybale","",19,[[["locationdescription",3]],["ordering",4]]],[11,"cmp","","",17,[[["bbinstrindex",4]],["ordering",4]]],[11,"eq","haybale::config","",2,[[["nullpointerchecking",4]],["bool",15]]],[11,"eq","","",3,[[["concretize",4]],["bool",15]]],[11,"ne","","",3,[[["concretize",4]],["bool",15]]],[11,"eq","haybale","",22,[[["error",4]],["bool",15]]],[11,"ne","","",22,[[["error",4]],["bool",15]]],[11,"eq","","",23,[[["parameterval",4]],["bool",15]]],[11,"ne","","",23,[[["parameterval",4]],["bool",15]]],[11,"eq","","",24,[[["returnvalue",4]],["bool",15]]],[11,"ne","","",24,[[["returnvalue",4]],["bool",15]]],[11,"eq","haybale::backend","",28,[[["cellmemorybackend",3]],["bool",15]]],[11,"eq","","",29,[[["defaultbackend",3]],["bool",15]]],[11,"eq","haybale::cell_memory","",9,[[],["bool",15]]],[11,"eq","haybale::config","",0,[[["demangling",4]],["bool",15]]],[11,"eq","haybale::simple_memory","",12,[[["memory",3]],["bool",15]]],[11,"ne","","",12,[[["memory",3]],["bool",15]]],[11,"eq","haybale::solver_utils","",13,[[["possiblesolutions",4]],["bool",15]]],[11,"ne","","",13,[[["possiblesolutions",4]],["bool",15]]],[11,"eq","","",14,[[["solutioncount",4]],["bool",15]]],[11,"ne","","",14,[[["solutioncount",4]],["bool",15]]],[11,"eq","haybale","",19,[[["locationdescription",3]],["bool",15]]],[11,"ne","","",19,[[["locationdescription",3]],["bool",15]]],[11,"eq","","",17,[[["bbinstrindex",4]],["bool",15]]],[11,"ne","","",17,[[["bbinstrindex",4]],["bool",15]]],[11,"eq","","",20,[[["pathentry",3]],["bool",15]]],[11,"ne","","",20,[[["pathentry",3]],["bool",15]]],[11,"eq","","",18,[[],["bool",15]]],[11,"eq","haybale::watchpoints","",15,[[["watchpoint",3]],["bool",15]]],[11,"ne","","",15,[[["watchpoint",3]],["bool",15]]],[11,"eq","haybale","",25,[[["solutionvalue",4]],["bool",15]]],[11,"ne","","",25,[[["solutionvalue",4]],["bool",15]]],[11,"partial_cmp","","",19,[[["locationdescription",3]],[["option",4],["ordering",4]]]],[11,"lt","","",19,[[["locationdescription",3]],["bool",15]]],[11,"le","","",19,[[["locationdescription",3]],["bool",15]]],[11,"gt","","",19,[[["locationdescription",3]],["bool",15]]],[11,"ge","","",19,[[["locationdescription",3]],["bool",15]]],[11,"partial_cmp","","",17,[[["bbinstrindex",4]],[["option",4],["ordering",4]]]],[11,"lt","","",17,[[["bbinstrindex",4]],["bool",15]]],[11,"le","","",17,[[["bbinstrindex",4]],["bool",15]]],[11,"gt","","",17,[[["bbinstrindex",4]],["bool",15]]],[11,"ge","","",17,[[["bbinstrindex",4]],["bool",15]]],[11,"fmt","haybale::config","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","haybale","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",23,[[["formatter",3]],["result",6]]],[11,"fmt","","",24,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::backend","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",29,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::cell_memory","",9,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::config","",0,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::simple_memory","",12,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::solver_utils","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","haybale","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::watchpoints","",15,[[["formatter",3]],["result",6]]],[11,"fmt","haybale","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","haybale::watchpoints","",15,[[["formatter",3]],["result",6]]],[11,"hash","haybale","",24,[[]]],[11,"hash","","",19,[[]]],[11,"hash","","",17,[[]]],[11,"hash","","",18,[[]]],[11,"hash","haybale::watchpoints","",15,[[]]],[11,"from_iter","haybale::solver_utils","Create a <code>PossibleSolutions::Exactly</code> from the contents of …",13,[[["intoiterator",8]]]],[11,"from_iter","haybale::watchpoints","",16,[[["intoiterator",8]]]],[11,"from_bc_path","haybale","Construct a new <code>Project</code> from a path to an LLVM bitcode …",26,[[],[["result",4],["string",3]]]],[11,"from_bc_paths","","Construct a new <code>Project</code> from multiple LLVM bitcode files",26,[[],[["result",4],["string",3]]]],[11,"from_bc_dir","","Construct a new <code>Project</code> from a path to a directory …",26,[[["str",15]],[["error",3],["result",4]]]],[11,"from_bc_dir_with_blacklist","","Construct a new <code>Project</code> from a path to a directory …",26,[[["str",15]],[["error",3],["result",4]]]],[11,"add_bc_path","","Add the code in the given LLVM bitcode file to the <code>Project</code>",26,[[],[["result",4],["string",3]]]],[11,"add_bc_dir","","Add the code in the given directory to the <code>Project</code>. See …",26,[[["str",15]],[["error",3],["result",4]]]],[11,"add_bc_dir_with_blacklist","","Add the code in the given directory, except for …",26,[[["str",15]],[["error",3],["result",4]]]],[11,"pointer_size_bits","","Get the pointer size used by the <code>Project</code>, in bits. E.g., …",26,[[],["u32",15]]],[11,"all_functions","","Iterate over all <code>Function</code>s in the <code>Project</code>. Gives pairs …",26,[[]]],[11,"all_global_vars","","Iterate over all <code>GlobalVariable</code>s in the <code>Project</code>. Gives …",26,[[]]],[11,"all_global_aliases","","Iterate over all <code>GlobalAlias</code>es in the <code>Project</code>. Gives …",26,[[]]],[11,"all_named_struct_types","","Iterate over all named struct types in the <code>Project</code>. Gives …",26,[[]]],[11,"active_module_names","","Get the names of the LLVM modules which have been parsed …",26,[[]]],[11,"get_func_by_name","","Search the project for a function with the given name. If …",26,[[["str",15]],["option",4]]],[11,"get_named_struct_def","","Get the definition of the named struct with the given …",26,[[["str",15]],["result",6]]],[11,"size_in_bits","","Get the size of the <code>Type</code>, in bits.",26,[[["type",4]],[["u32",15],["option",4]]]],[11,"fp_size_in_bits","","Get the size of the <code>FPType</code>, in bits",26,[[["fptype",4]],["u32",15]]],[11,"func","","Reference to the <code>Function</code> which the <code>ExecutionManager</code> is …",27,[[],["function",3]]],[11,"state","","Provides access to the <code>State</code> resulting from the end of …",27,[[],["state",3]]],[11,"mut_state","","Provides mutable access to the underlying <code>State</code> (see …",27,[[],["state",3]]],[11,"param_bvs","","Provides access to the <code>BV</code> objects representing each of …",27,[[],["vec",3]]],[11,"to_string_with_module","","Format this <code>Location</code> as a string, including the full …",18,[[],["string",3]]],[11,"to_string_no_module","","Format this <code>Location</code> as a string, omitting the module name",18,[[],["string",3]]],[11,"to_string_short_module","","Format this <code>Location</code> as a string, including the short …",18,[[],["string",3]]],[11,"new","","<code>start_loc</code>: the <code>Location</code> where the <code>State</code> should begin …",21,[[["config",3],["project",3],["location",3]]]],[11,"fork","","Fully duplicate the <code>State</code>. Unlike with <code>clone()</code>, the <code>State</code> …",21,[[]]],[11,"sat","","Returns <code>true</code> if current constraints are satisfiable, <code>false</code>…",21,[[],[["bool",15],["result",6]]]],[11,"sat_with_extra_constraints","","Returns <code>true</code> if the current constraints plus the given …",21,[[],[["bool",15],["result",6]]]],[11,"get_bv_by_irname","","Get the <code>BV</code> corresponding to the given IR <code>Name</code> (from the …",21,[[["string",3],["name",4]]]],[11,"bvs_must_be_equal","","Returns <code>true</code> if under the current constraints, <code>a</code> and <code>b</code> …",21,[[],[["bool",15],["result",6]]]],[11,"bvs_can_be_equal","","Returns <code>true</code> if under the current constraints, <code>a</code> and <code>b</code> …",21,[[],[["bool",15],["result",6]]]],[11,"get_a_solution_for_bv","","Get one possible concrete value for the <code>BV</code>. Returns …",21,[[],[["result",6],["option",4]]]],[11,"get_a_solution_for_irname","","Get one possible concrete value for the given IR <code>Name</code> …",21,[[["string",3],["name",4]],[["result",6],["option",4]]]],[11,"get_possible_solutions_for_bv","","Get a description of the possible solutions for the <code>BV</code>.",21,[[["usize",15]],[["possiblesolutions",4],["result",6]]]],[11,"get_possible_solutions_for_irname","","Get a description of the possible solutions for the given …",21,[[["string",3],["name",4],["usize",15]],[["possiblesolutions",4],["result",6]]]],[11,"max_possible_solution_for_bv_as_u64","","Get the maximum possible solution for the <code>BV</code>: that is, …",21,[[],[["result",6],["option",4]]]],[11,"max_possible_solution_for_irname_as_u64","","Get the maximum possible solution for the given IR <code>Name</code> …",21,[[["string",3],["name",4]],[["result",6],["option",4]]]],[11,"min_possible_solution_for_bv_as_u64","","Get the minimum possible solution for the <code>BV</code>: that is, …",21,[[],[["result",6],["option",4]]]],[11,"min_possible_solution_for_irname_as_u64","","Get the minimum possible solution for the given IR <code>Name</code> …",21,[[["string",3],["name",4]],[["result",6],["option",4]]]],[11,"bv_from_bool","","Create a <code>BV</code> constant representing the given <code>bool</code> (either …",21,[[["bool",15]]]],[11,"bv_from_i32","","Create a <code>BV</code> representing the given constant <code>i32</code> value, …",21,[[["u32",15],["i32",15]]]],[11,"bv_from_u32","","Create a <code>BV</code> representing the given constant <code>u32</code> value, …",21,[[["u32",15]]]],[11,"bv_from_i64","","Create a <code>BV</code> representing the given constant <code>i64</code> value, …",21,[[["i64",15],["u32",15]]]],[11,"bv_from_u64","","Create a <code>BV</code> representing the given constant <code>u64</code> value, …",21,[[["u32",15],["u64",15]]]],[11,"zero","","Create a <code>BV</code> representing the constant <code>0</code> of the given …",21,[[["u32",15]]]],[11,"one","","Create a <code>BV</code> representing the constant <code>1</code> of the given …",21,[[["u32",15]]]],[11,"ones","","Create a <code>BV</code> constant of the given width, where all bits …",21,[[["u32",15]]]],[11,"new_bv_with_name","","Create a new (unconstrained) <code>BV</code> for the given <code>Name</code> (in …",21,[[["u32",15],["name",4]],["result",6]]],[11,"assign_bv_to_name","","Assign the given <code>BV</code> to the given <code>Name</code> (in the current …",21,[[["name",4]],["result",6]]],[11,"record_bv_result","","Record the result of <code>thing</code> to be <code>resultval</code>. Assumes <code>thing</code> …",21,[[],["result",6]]],[11,"overwrite_latest_version_of_bv","","Overwrite the latest version of the given <code>Name</code> to instead …",21,[[["name",4]]]],[11,"type_of","","Convenience function to get the <code>Type</code> of anything that is …",21,[[],["typeref",3]]],[11,"operand_to_bv","","Convert an <code>Operand</code> to the appropriate <code>BV</code>. Assumes the …",21,[[["operand",4]],["result",6]]],[11,"const_to_bv","","Convert a <code>Constant</code> to the appropriate <code>BV</code>.",21,[[["constant",4]],["result",6]]],[11,"get_pointer_to_function","","Get a pointer to the given function name. The name must …",21,[[],["option",4]]],[11,"get_pointer_to_function_hook","","Get a pointer to the currently active <em>hook</em> for the given …",21,[[["str",15]],["option",4]]],[11,"get_func_by_name","","Get a <code>Function</code> by name. The name must be the …",21,[[],["option",4]]],[11,"read","","Read a value <code>bits</code> bits long from memory at <code>addr</code>. Note …",21,[[["u32",15]],["result",6]]],[11,"write","","Write a value into memory at <code>addr</code>. Note that <code>val</code> can be …",21,[[],["result",6]]],[11,"size","","Get the size of the <code>Type</code>, in bits.",21,[[["type",4]],["u32",15]]],[11,"size_opaque_aware","","Get the size of the <code>Type</code>, in bits.",21,[[["project",3],["type",4]],[["u32",15],["option",4]]]],[11,"size_in_bits","","Get the size of the <code>Type</code>, in bits.",21,[[["type",4]],[["u32",15],["option",4]]]],[11,"fp_size","","Get the size of the <code>FPType</code>, in bits",21,[[["fptype",4]],["u32",15]]],[11,"fp_size_in_bits","","",21,[[["fptype",4]],["u32",15]]],[11,"get_offset_constant_index","","Get the offset (in <em>bytes</em>) of the element at the given …",21,[[["usize",15],["type",4]],["result",6]]],[11,"get_offset_bv_index","","Get the offset (in <em>bytes</em>) of the element at the given …",21,[[["type",4]],["result",6]]],[11,"add_mem_watchpoint","","Add a memory watchpoint. It will be enabled unless/until …",21,[[["watchpoint",3]],["bool",15]]],[11,"rm_mem_watchpoint","","Remove the memory watchpoint with the given <code>name</code>.",21,[[["str",15]],["bool",15]]],[11,"disable_watchpoint","","Disable the memory watchpoint with the given <code>name</code>. …",21,[[["str",15]],["bool",15]]],[11,"enable_watchpoint","","Enable the memory watchpoint(s) with the given name.",21,[[["str",15]],["bool",15]]],[11,"allocate","","Allocate a value of size <code>bits</code>; return a pointer to the …",21,[[]]],[11,"get_allocation_size","","Get the size, in bits, of the allocation at the given …",21,[[],[["result",6],["option",4]]]],[11,"record_path_entry","","Record the current location as a <code>PathEntry</code> in the current …",21,[[]]],[11,"get_path","","Get the <code>PathEntry</code>s that have been recorded, in order",21,[[],["vec",3]]],[11,"push_callsite","","Record entering a normal <code>Call</code> at the current location",21,[[["call",3]]]],[11,"push_invokesite","","Record entering the given <code>Invoke</code> at the current location",21,[[["invoke",3]]]],[11,"pop_callsite","","Record leaving the current function. Returns the <code>Callsite</code> …",21,[[],[["option",4],["callsite",3]]]],[11,"current_callstack_depth","","Returns the current callstack depth. <code>0</code> indicates we\'re in …",21,[[],["usize",15]]],[11,"save_backtracking_point","","Save the current state, about to enter the <code>BasicBlock</code> …",21,[[["name",4]]]],[11,"revert_to_backtracking_point","","returns <code>Ok(true)</code> if the operation was successful, …",21,[[],[["bool",15],["result",6]]]],[11,"count_backtracking_points","","returns the number of saved backtracking points",21,[[],["usize",15]]],[11,"pretty_backtrace","","returns a <code>String</code> containing a formatted view of the …",21,[[],["string",3]]],[11,"pretty_path_llvm","","returns a <code>String</code> containing a formatted view of the full …",21,[[],["string",3]]],[11,"pretty_path_llvm_instructions","","returns a <code>String</code> containing a formatted view of the full …",21,[[],["string",3]]],[11,"pretty_path_source","","returns a <code>String</code> containing a formatted view of the full …",21,[[],["string",3]]],[11,"pretty_path_interleaved","","returns a <code>String</code> containing a formatted view of the full …",21,[[],["string",3]]],[11,"get_path_length","","Returns the number of LLVM instructions in the current …",21,[[],["usize",15]]],[11,"demangle","","Attempt to demangle the given <code>funcname</code> as appropriate …",21,[[["str",15]],["string",3]]],[11,"all_vars_in_cur_fn","","Get the most recent <code>BV</code> created for each <code>Name</code> in the …",21,[[]]],[11,"current_assignments_as_pretty_string","","returns a <code>String</code> describing a set of satisfying …",21,[[],[["result",6],["string",3]]]],[11,"full_error_message_with_context","","Returns a <code>String</code> describing both the error and the …",21,[[["error",4]],["string",3]]]],"p":[[4,"Demangling"],[3,"Config"],[4,"NullPointerChecking"],[4,"Concretize"],[8,"Backend"],[8,"SolverRef"],[8,"BV"],[8,"Memory"],[3,"Callbacks"],[3,"Memory"],[8,"IsCall"],[3,"FunctionHooks"],[3,"Memory"],[4,"PossibleSolutions"],[4,"SolutionCount"],[3,"Watchpoint"],[3,"Watchpoints"],[4,"BBInstrIndex"],[3,"Location"],[3,"LocationDescription"],[3,"PathEntry"],[3,"State"],[4,"Error"],[4,"ParameterVal"],[4,"ReturnValue"],[4,"SolutionValue"],[3,"Project"],[3,"ExecutionManager"],[3,"CellMemoryBackend"],[3,"DefaultBackend"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);